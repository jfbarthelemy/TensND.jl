var documenterSearchIndex = {"docs":
[{"location":"man/tensors/#Tensors","page":"Tensors","title":"Tensors","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"A tensor, parametrized by an order and a dimension, is in general defined by","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"an array or a set of condensed parameters (e.g. isotropic tensors),\na basis,\na set of variances (covariant :cov or contravariant :cont) useful if the basis is not orthonormal.","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"In practice, the type of basis conditions the type of tensor (TensCanonical, TensRotated, TensOrthogonal, Tens or even TensISO in case of isotropic tensor).","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"julia> ℬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0])\nBasis{3, Sym}\n→ basis: 3×3 Matrix{Sym}:\n 0  1  1\n 1  0  1\n 1  1  0\n→ dual basis: 3×3 Matrix{Sym}:\n -1/2   1/2   1/2\n  1/2  -1/2   1/2\n  1/2   1/2  -1/2\n→ covariant metric tensor: 3×3 Symmetric{Sym, Matrix{Sym}}:\n 2  1  1\n 1  2  1\n 1  1  2\n→ contravariant metric tensor: 3×3 Symmetric{Sym, Matrix{Sym}}:\n  3/4  -1/4  -1/4\n -1/4   3/4  -1/4\n -1/4  -1/4   3/4\n\njulia> V = Tens(Tensor{1,3}(i -> symbols(\"v$i\", real = true)))\n(v1)𝐞¹ + (v2)𝐞² + (v3)𝐞³\n\njulia> components(V, ℬ, (:cont,))\n3-element Vector{Sym}:\n -v1/2 + v2/2 + v3/2\n  v1/2 - v2/2 + v3/2\n  v1/2 + v2/2 - v3/2\n\njulia> components(V, ℬ, (:cov,))\n3-element Vector{Sym}:\n v₂ + v₃\n v₁ + v₃\n v₁ + v₂\n\njulia> ℬ̄ = normalize(ℬ)\nBasis{3, Sym}\n→ basis: 3×3 Matrix{Sym}:\n         0  sqrt(2)/2  sqrt(2)/2\n sqrt(2)/2          0  sqrt(2)/2\n sqrt(2)/2  sqrt(2)/2          0\n→ dual basis: 3×3 Matrix{Sym}:\n -sqrt(2)/2   sqrt(2)/2   sqrt(2)/2\n  sqrt(2)/2  -sqrt(2)/2   sqrt(2)/2\n  sqrt(2)/2   sqrt(2)/2  -sqrt(2)/2\n→ covariant metric tensor: 3×3 Symmetric{Sym, Matrix{Sym}}:\n   1  1/2  1/2\n 1/2    1  1/2\n 1/2  1/2    1\n→ contravariant metric tensor: 3×3 Symmetric{Sym, Matrix{Sym}}:\n  3/2  -1/2  -1/2\n -1/2   3/2  -1/2\n -1/2  -1/2   3/2\n\njulia> components(V, ℬ̄, (:cov,))\n3-element Vector{Sym}:\n sqrt(2)*v2/2 + sqrt(2)*v3/2\n sqrt(2)*v1/2 + sqrt(2)*v3/2\n sqrt(2)*v1/2 + sqrt(2)*v2/2\n\njulia> T = Tens(Tensor{2,3}((i, j) -> symbols(\"t$i$j\", real = true)))\n(t11)𝐞¹⊗𝐞¹ + (t21)𝐞²⊗𝐞¹ + (t31)𝐞³⊗𝐞¹ + (t12)𝐞¹⊗𝐞² + (t22)𝐞²⊗𝐞² + (t32)𝐞³⊗𝐞² + (t13)𝐞¹⊗𝐞³ + (t23)𝐞²⊗𝐞³ + (t33)𝐞³⊗𝐞³\n\njulia> components(T, ℬ, (:cov, :cov))\n3×3 Matrix{Sym}:\n t₂₂ + t₂₃ + t₃₂ + t₃₃  t₂₁ + t₂₃ + t₃₁ + t₃₃  t₂₁ + t₂₂ + t₃₁ + t₃₂\n t₁₂ + t₁₃ + t₃₂ + t₃₃  t₁₁ + t₁₃ + t₃₁ + t₃₃  t₁₁ + t₁₂ + t₃₁ + t₃₂\n t₁₂ + t₁₃ + t₂₂ + t₂₃  t₁₁ + t₁₃ + t₂₁ + t₂₃  t₁₁ + t₁₂ + t₂₁ + t₂₂\n\njulia> factor(simplify(components(T, ℬ, (:cont, :cov))))\n3×3 Matrix{Sym}:\n -(t12 + t13 - t22 - t23 - t32 - t33)/2  -(t11 + t13 - t21 - t23 - t31 - t33)/2  -(t11 + t12 - t21 - t22 - t31 - t32)/2\n  (t12 + t13 - t22 - t23 + t32 + t33)/2   (t11 + t13 - t21 - t23 + t31 + t33)/2   (t11 + t12 - t21 - t22 + t31 + t32)/2\n  (t12 + t13 + t22 + t23 - t32 - t33)/2   (t11 + t13 + t21 + t23 - t31 - t33)/2   (t11 + t12 + t21 + t22 - t31 - t32)/2","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"Special tensors are available","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"tensId2(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: second-order identity (𝟏ᵢⱼ = δᵢⱼ = 1 if i=j otherwise 0)\ntensId4(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: fourth-order identity with minor symmetries (𝕀 = 𝟏 ⊠ˢ 𝟏 i.e. (𝕀)ᵢⱼₖₗ = (δᵢₖδⱼₗ+δᵢₗδⱼₖ)/2)\ntensJ4(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: fourth-order spherical projector (𝕁 = (𝟏 ⊗ 𝟏) / dim i.e. (𝕁)ᵢⱼₖₗ = δᵢⱼδₖₗ/dim)\ntensK4(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: fourth-order deviatoric projector (𝕂 = 𝕀 - 𝕁 i.e. (𝕂)ᵢⱼₖₗ = (δᵢₖδⱼₗ+δᵢₗδⱼₖ)/2 - δᵢⱼδₖₗ/dim)\nISO(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: returns 𝕀, 𝕁, 𝕂","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"The useful tensor products are the following:","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"⊗ tensor product\n⊗ˢ symmetrized tensor product\n⊠ modified tensor product\n⊠ˢ symmetrized modified tensor product\n⋅ contracted product\n⊡ double contracted product\n⊙ quadruple contracted product","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"NOTE: more information about modified tensor products can be found in Sébastien Brisard's blog.","category":"page"},{"location":"man/tensors/","page":"Tensors","title":"Tensors","text":"julia> 𝟏 = tensId2(3, Sym)\n(1) 𝟏\n\njulia> 𝕀, 𝕁, 𝕂 = ISO(3, Sym) ;\n\njulia> 𝕀 == 𝟏 ⊠ˢ 𝟏\ntrue\n\njulia> 𝕁 == (𝟏 ⊗ 𝟏)/3\ntrue\n\njulia> a = Tens(Vec{3}((i,) -> symbols(\"a$i\", real = true))) ;\n\njulia> b = Tens(Vec{3}((i,) -> symbols(\"b$i\", real = true))) ;\n\njulia> a ⊗ b\n(a1*b1)𝐞¹⊗𝐞¹ + (a2*b1)𝐞²⊗𝐞¹ + (a3*b1)𝐞³⊗𝐞¹ + (a1*b2)𝐞¹⊗𝐞² + (a2*b2)𝐞²⊗𝐞² + (a3*b2)𝐞³⊗𝐞² + (a1*b3)𝐞¹⊗𝐞³ + (a2*b3)𝐞²⊗𝐞³ + (a3*b3)𝐞³⊗𝐞³\n\njulia> a ⊗ˢ b\n(a1*b1)𝐞¹⊗𝐞¹ + (a1*b2/2 + a2*b1/2)𝐞²⊗𝐞¹ + (a1*b3/2 + a3*b1/2)𝐞³⊗𝐞¹ + (a1*b2/2 + a2*b1/2)𝐞¹⊗𝐞² + (a2*b2)𝐞²⊗𝐞² + (a2*b3/2 + a3*b2/2)𝐞³⊗𝐞² + (a1*b3/2 + a3*b1/2)𝐞¹⊗𝐞³\n + (a2*b3/2 + a3*b2/2)𝐞²⊗𝐞³ + (a3*b3)𝐞³⊗𝐞³\n\njulia> (θ, ϕ, r), (𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ), ℬˢ = init_spherical()\n((θ, ϕ, r), (Sym[1, 0, 0], Sym[0, 1, 0], Sym[0, 0, 1]), Sym[cos(θ)*cos(ϕ) -sin(ϕ) sin(θ)*cos(ϕ); sin(ϕ)*cos(θ) cos(ϕ) sin(θ)*sin(ϕ); -sin(θ) 0 cos(θ)])\n\njulia> R = rot3(θ, ϕ)\n3×3 RotZYZ{Sym} with indices SOneTo(3)×SOneTo(3)(ϕ, θ, 0):\n cos(θ)⋅cos(ϕ)  -sin(ϕ)  sin(θ)⋅cos(ϕ)\n sin(ϕ)⋅cos(θ)   cos(ϕ)  sin(θ)⋅sin(ϕ)\n       -sin(θ)        0         cos(θ)\n\njulia> A = Tens(R * a)\n(a1*cos(θ)*cos(ϕ) - a2*sin(ϕ) + a3*sin(θ)*cos(ϕ))𝐞¹ + (a1*sin(ϕ)*cos(θ) + a2*cos(ϕ) + a3*sin(θ)*sin(ϕ))𝐞² + (-a1*sin(θ) + a3*cos(θ))𝐞³\n\njulia> simplify(change_tens(A, ℬˢ))\n(a1)𝐞¹ + (a2)𝐞² + (a3)𝐞³","category":"page"},{"location":"man/bases/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"An arbitrary basis contains four matrices","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"one in which columns correspond to the covariant vectors of new basis (𝐞ᵢ) with respect to the canonical one,\none defining the contravariant (or dual) basis (𝐞ⁱ),\none defining the metric tensor gᵢⱼ=𝐞ᵢ⋅𝐞ⱼ,\none defining the inverse of the  metric tensor gⁱʲ=𝐞ⁱ⋅𝐞ʲ.","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"and is built by one the following constructors","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"Basis(eᵢ::AbstractMatrix{T},eⁱ::AbstractMatrix{T},gᵢⱼ::AbstractMatrix{T},gⁱʲ::AbstractMatrix{T}) where {T}\nBasis(ℬ::AbstractBasis{dim,T}, χᵢ::V) where {dim,T,V} where χᵢ is a list of scaling factors applied on the vectors of the basis ℬ\nBasis(v::AbstractMatrix{T}, var::Symbol)\nBasis(θ::T1, ϕ::T2, ψ::T3 = 0) where {T1,T2,T3}\nBasis(θ::T) where {T}\nBasis{dim,T}() where {dim,T}","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"Depending on the property of the basis (canonical, orthonormal, orthogonal...), the most relevant type (CanonicalBasis, RotatedBasis, OrthogonalBasis or Basis) is implicitly created by calling Basis.","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"julia> ℬ = Basis(Sym[1 0 0; 0 1 0; 0 1 1])\nBasis{3, Sym}\n→ basis: 3×3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  1  1      \n→ dual basis: 3×3 Matrix{Sym}:\n 1  0   0\n 0  1  -1\n 0  0   1\n→ covariant metric tensor: 3×3 Symmetric{Sym, Matrix{Sym}}:\n 1  0  0\n 0  2  1\n 0  1  1\n→ contravariant metric tensor: 3×3 Symmetric{Sym, Matrix{Sym}}:\n 1   0   0\n 0   1  -1\n 0  -1   2\n\njulia> ℬ₂ = Basis(symbols(\"θ, ϕ, ψ\", real = true)...)\nRotatedBasis{3, Sym}\n→ basis: 3×3 Matrix{Sym}:\n -sin(ψ)⋅sin(ϕ) + cos(θ)⋅cos(ψ)⋅cos(ϕ)  -sin(ψ)⋅cos(θ)⋅cos(ϕ) - sin(ϕ)⋅cos(ψ)  sin(θ)⋅cos(ϕ)\n  sin(ψ)⋅cos(ϕ) + sin(ϕ)⋅cos(θ)⋅cos(ψ)  -sin(ψ)⋅sin(ϕ)⋅cos(θ) + cos(ψ)⋅cos(ϕ)  sin(θ)⋅sin(ϕ)\n                        -sin(θ)⋅cos(ψ)                          sin(θ)⋅sin(ψ)         cos(θ)\n→ dual basis: 3×3 Matrix{Sym}:\n -sin(ψ)⋅sin(ϕ) + cos(θ)⋅cos(ψ)⋅cos(ϕ)  -sin(ψ)⋅cos(θ)⋅cos(ϕ) - sin(ϕ)⋅cos(ψ)  sin(θ)⋅cos(ϕ)\n  sin(ψ)⋅cos(ϕ) + sin(ϕ)⋅cos(θ)⋅cos(ψ)  -sin(ψ)⋅sin(ϕ)⋅cos(θ) + cos(ψ)⋅cos(ϕ)  sin(θ)⋅sin(ϕ)\n                        -sin(θ)⋅cos(ψ)                          sin(θ)⋅sin(ψ)         cos(θ)\n→ covariant metric tensor: 3×3 TensND.Id2{3, Sym}:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1\n→ contravariant metric tensor: 3×3 TensND.Id2{3, Sym}:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"Predefined symbolic or numerical coordinates and basis vectors can be obtained from","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"init_cartesian(dim::Integer)\ninit_polar(coords = (symbols(\"r\", positive = true), symbols(\"θ\", real = true)); canonical = false)\ninit_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"θ\", real = true), symbols(\"z\", real = true)); canonical = false)\ninit_spherical(coords = (symbols(\"θ\", real = true), symbols(\"ϕ\", real = true), symbols(\"r\", positive = true)); canonical = false)\ninit_rotated(coords = symbols(\"θ ϕ ψ\", real = true); canonical = false)","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"The option canonical specifies whether the vector is expressed as a tensor with components in the canonical basis or directly in the rotated basis. The second option (ie canonical = false by default) is often preferable for further calculations in the rotated basis.","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"julia> (x, y, z), (𝐞₁, 𝐞₂, 𝐞₃), ℬ = init_cartesian() ;\n\njulia> (r, θ), (𝐞ʳ, 𝐞ᶿ), ℬᵖ = init_polar() ;\n\njulia> (r, θ, z), (𝐞ʳ, 𝐞ᶿ, 𝐞ᶻ), ℬᶜ = init_cylindrical() ;\n\njulia> display(ℬᶜ)\nRotatedBasis{3, Sym}\n→ basis: 3×3 Matrix{Sym}:\n cos(θ)  -sin(θ)  0\n sin(θ)   cos(θ)  0\n      0        0  1\n→ dual basis: 3×3 Matrix{Sym}:\n cos(θ)  -sin(θ)  0\n sin(θ)   cos(θ)  0\n      0        0  1\n→ covariant metric tensor: 3×3 TensND.Id2{3, Sym}:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1\n→ contravariant metric tensor: 3×3 TensND.Id2{3, Sym}:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1\n\njulia> (θ, ϕ, r), (𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ), ℬˢ = init_spherical() ;\n\njulia> components_canon(𝐞ʳ)\n3-element Vector{Sym}:\n sin(θ)⋅cos(ϕ)\n sin(θ)⋅sin(ϕ)\n        cos(θ)\n\njulia> (θ, ϕ, ψ), (𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ), ℬʳ = init_rotated() ;","category":"page"},{"location":"man/bases/","page":"Bases","title":"Bases","text":"NOTE: it is worth noting the unusual order of coordinates and vectors of the spherical basis which have been chosen here so that θ = ϕ = 0 corresponds to the cartesian basis in the correct order.","category":"page"},{"location":"api/#API-of-the-TensND-library","page":"API","title":"API of the TensND library","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [TensND]","category":"page"},{"location":"api/#TensND.Basis","page":"API","title":"TensND.Basis","text":"Basis(v::AbstractMatrix{T}, ::Val{:cov})\nBasis{dim, T<:Number}()\nBasis(θ::T<:Number, ϕ::T<:Number, ψ::T<:Number)\n\nBasis built from a square matrix v where columns correspond either to\n\nprimal vectors ie eᵢ=v[:,i] if var=:cov as by default\ndual vectors ie eⁱ=v[:,i] if var=:cont.\n\nBasis without any argument refers to the canonical basis (CanonicalBasis) in Rᵈⁱᵐ (by default dim=3 and T=Sym)\n\nBasis can also be built from Euler angles (RotatedBasis) θ in 2D and (θ, ϕ, ψ) in 3D\n\nThe attributes of this object can be obtained by\n\nvecbasis(ℬ, :cov): square matrix defining the primal basis eᵢ=e[:,i]\nvecbasis(ℬ, :cont): square matrix defining the dual basis eⁱ=E[:,i]\nmetric(ℬ, :cov): square matrix defining the covariant components of the metric tensor gᵢⱼ=eᵢ⋅eⱼ=g[i,j]\nmetric(ℬ, :cont): square matrix defining the contravariant components of the metric tensor gⁱʲ=eⁱ⋅eʲ=gⁱʲ[i,j]\n\nExamples\n\njulia> v = Sym[1 0 0; 0 1 0; 0 1 1] ; ℬ = Basis(v)\nBasis{3, Sym}\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# dual basis: 3×3 Tensor{2, 3, Sym, 9}:\n 1  0   0\n 0  1  -1\n 0  0   1\n# covariant metric tensor: 3×3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# contravariant metric tensor: 3×3 SymmetricTensor{2, 3, Sym, 6}:\n 1   0   0\n 0   1  -1\n 0  -1   2\n\njulia> θ, ϕ, ψ = symbols(\"θ, ϕ, ψ\", real = true) ; ℬʳ = Basis(θ, ϕ, ψ) ; display(vecbasis(ℬʳ, :cov))\n3×3 Tensor{2, 3, Sym, 9}:\n -sin(ψ)⋅sin(ϕ) + cos(θ)⋅cos(ψ)⋅cos(ϕ)  -sin(ψ)⋅cos(θ)⋅cos(ϕ) - sin(ϕ)⋅cos(ψ)  sin(θ)⋅cos(ϕ)\n  sin(ψ)⋅cos(ϕ) + sin(ϕ)⋅cos(θ)⋅cos(ψ)  -sin(ψ)⋅sin(ϕ)⋅cos(θ) + cos(ψ)⋅cos(ϕ)  sin(θ)⋅sin(ϕ)\n                        -sin(θ)⋅cos(ψ)                          sin(θ)⋅sin(ψ)         cos(θ)\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.CanonicalBasis","page":"API","title":"TensND.CanonicalBasis","text":"CanonicalBasis{dim, T}\n\nCanonical basis of dimension dim (default: 3) and type T (default: Sym)\n\nThe attributes of this object can be obtained by\n\nvecbasis(ℬ, :cov): square matrix defining the primal basis eᵢ=e[:,i]=δᵢⱼ\nvecbasis(ℬ, :cont): square matrix defining the dual basis eⁱ=E[:,i]=δᵢⱼ\nmetric(ℬ, :cov): square matrix defining the covariant components of the metric tensor gᵢⱼ=eᵢ⋅eⱼ=g[i,j]=δᵢⱼ\nmetric(ℬ, :cont): square matrix defining the contravariant components of the metric tensor gⁱʲ=eⁱ⋅eʲ=gⁱʲ[i,j]=δᵢⱼ\n\nExamples\n\njulia> ℬ = CanonicalBasis()\nCanonicalBasis{3, Sym}\n# basis: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# dual basis: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# covariant metric tensor: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# contravariant metric tensor: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> ℬ₂ = CanonicalBasis{2, Float64}()\nCanonicalBasis{2, Float64}\n# basis: 2×2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# dual basis: 2×2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# covariant metric tensor: 2×2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# contravariant metric tensor: 2×2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.CoorSystemSym","page":"API","title":"TensND.CoorSystemSym","text":"CoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},bnorm::AbstractBasis{dim,Sym},χᵢ::NTuple{dim},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\nCoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\n\nDefine a new coordinate system either from\n\nthe position vector OM, the coordinates coords, the basis of unit vectors (𝐞ᵢ) bnorm and the Lamé coefficients χᵢ\nIn this case the natural basis is formed by the vectors 𝐚ᵢ = χᵢ 𝐞ᵢ directly calculated from the input data.\nor the position vector OM and the coordinates coords\nIn this case the natural basis is formed by the vectors 𝐚ᵢ = ∂ᵢOM i.e. by the derivative of the position vector with respect to the iᵗʰ coordinate\n\nOptional parameters can be provided:\n\ntmp_coords contains temporary variables depending on coordinates (in order to allow symbolic simplifications)\nparams contains possible parameters involved in OM\nrules contains a Dict with substitution rules to facilitate the simplification of formulas\ntmp_var contains a Dict with substitution of coordinates by temporary variables\nto_coords indicates how to eliminate the temporary variables to come back to the actual coordinates before derivation for Examples\n\nExamples\n\njulia> ϕ, p = symbols(\"ϕ p\", real = true) ;\n\njulia> p̄, q, q̄, c = symbols(\"p̄ q q̄ c\", positive = true) ;\n\njulia> coords = (ϕ, p, q) ; tmp_coords = (p̄, q̄) ; params = (c,) ;\n\njulia> OM = Tens(c * [p̄ * q̄ * cos(ϕ), p̄ * q̄ * sin(ϕ), p * q]) ;\n\njulia> Spheroidal = CoorSystemSym(OM, coords, tmp_coords, params; tmp_var = Dict(1-p^2 => p̄^2, q^2-1 => q̄^2), to_coords = Dict(p̄ => √(1-p^2), q̄ => √(q^2-1))) ;\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.RotatedBasis","page":"API","title":"TensND.RotatedBasis","text":"RotatedBasis(θ::T<:Number, ϕ::T<:Number, ψ::T<:Number)\nRotatedBasis(θ::T<:Number)\n\nOrthonormal basis of dimension dim (default: 3) and type T (default: Sym) built from Euler angles θ in 2D and (θ, ϕ, ψ) in 3D\n\nExamples\n\njulia> θ, ϕ, ψ = symbols(\"θ, ϕ, ψ\", real = true) ; ℬʳ = RotatedBasis(θ, ϕ, ψ) ; display(vecbasis(ℬʳ, :cov))\n3×3 Tensor{2, 3, Sym, 9}:\n -sin(ψ)⋅sin(ϕ) + cos(θ)⋅cos(ψ)⋅cos(ϕ)  -sin(ψ)⋅cos(θ)⋅cos(ϕ) - sin(ϕ)⋅cos(ψ)  sin(θ)⋅cos(ϕ)\n  sin(ψ)⋅cos(ϕ) + sin(ϕ)⋅cos(θ)⋅cos(ψ)  -sin(ψ)⋅sin(ϕ)⋅cos(θ) + cos(ψ)⋅cos(ϕ)  sin(θ)⋅sin(ϕ)\n                        -sin(θ)⋅cos(ψ)                          sin(θ)⋅sin(ψ)         cos(θ)\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.SubManifoldSym","page":"API","title":"TensND.SubManifoldSym","text":"CoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},bnorm::AbstractBasis{dim,Sym},χᵢ::NTuple{dim},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\nCoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\n\nDefine a new coordinate system either from\n\nthe position vector OM, the coordinates coords, the basis of unit vectors (𝐞ᵢ) bnorm and the Lamé coefficients χᵢ\nIn this case the natural basis is formed by the vectors 𝐚ᵢ = χᵢ 𝐞ᵢ directly calculated from the input data.\nor the position vector OM and the coordinates coords\nIn this case the natural basis is formed by the vectors 𝐚ᵢ = ∂ᵢOM i.e. by the derivative of the position vector with respect to the iᵗʰ coordinate\n\nOptional parameters can be provided:\n\ntmp_coords contains temporary variables depending on coordinates (in order to allow symbolic simplifications)\nparams contains possible parameters involved in OM\nrules contains a Dict with substitution rules to facilitate the simplification of formulas\ntmp_var contains a Dict with substitution of coordinates by temporary variables\nto_coords indicates how to eliminate the temporary variables to come back to the actual coordinates before derivation for Examples\n\nExamples\n\njulia> ϕ, p = symbols(\"ϕ p\", real = true) ;\n\njulia> p̄, q, q̄, c = symbols(\"p̄ q q̄ c\", positive = true) ;\n\njulia> coords = (ϕ, p, q) ; tmp_coords = (p̄, q̄) ; params = (c,) ;\n\njulia> OM = Tens(c * [p̄ * q̄ * cos(ϕ), p̄ * q̄ * sin(ϕ), p * q]) ;\n\njulia> Spheroidal = CoorSystemSym(OM, coords, tmp_coords, params; tmp_var = Dict(1-p^2 => p̄^2, q^2-1 => q̄^2), to_coords = Dict(p̄ => √(1-p^2), q̄ => √(q^2-1))) ;\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.Tens","page":"API","title":"TensND.Tens","text":"Tens{order,dim,T,A<:AbstractArray}\n\nTensor type of any order defined by\n\na multidata of components (of any type heriting from AbstractArray, e.g. Tensor or SymmetricTensor)\na basis of AbstractBasis type\na tuple of variances (covariant :cov or contravariant :cont) of length equal to the order of the tensor\n\nExamples\n\njulia> ℬ = Basis(Sym[1 0 0; 0 1 0; 0 1 1]) ;\n\njulia> T = Tens(metric(ℬ,:cov),ℬ,(:cov,:cov))\nTens{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3×3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# var: (:cov, :cov)\n\njulia> components(T,(:cont,:cov),b)\n3×3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"type"},{"location":"api/#LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"LinearAlgebra.dot","text":"dot(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a contracted product between two tensors\n\na ⋅ b = aⁱbⱼ\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.normalize","page":"API","title":"LinearAlgebra.normalize","text":"normalize(ℬ::AbstractBasis, var = cov)\n\nBuild a basis after normalization of column vectors of input matrix v where columns define either\n\nprimal vectors ie eᵢ=v[:,i]/norm(v[:,i]) if var = :cov as by default\ndual vector ie eⁱ=v[:,i]/norm(v[:,i]) if var = :cont.\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.DIV-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Sym, Symbolics.Num}}","page":"API","title":"TensND.DIV","text":"DIV(t::AbstractTens{order,dim,Sym},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the divergence  of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.DIV-Union{Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, Sym}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.DIV","text":"DIV(T::AbstractTens{order,dim,Sym},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the divergence  of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.GRAD-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Sym, Symbolics.Num}}","page":"API","title":"TensND.GRAD","text":"GRAD(t::Union{t,AbstractTens{order,dim,T}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the gradient of t with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.GRAD-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.GRAD","text":"GRAD(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the gradient of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.HESS-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Sym, Symbolics.Num}}","page":"API","title":"TensND.HESS","text":"HESS(t::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the Hessian of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.HESS-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.HESS","text":"HESS(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the Hessian of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.ISO-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.ISO","text":"ISO(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nReturn the three fourth-order isotropic tensors 𝕀, 𝕁, 𝕂\n\nExamples\n\njulia> 𝕀, 𝕁, 𝕂 = ISO() ;\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T}, Tensors.SymmetricTensor{4, dim, T}, Tensors.Tensor{2, dim, T}, Tensors.Tensor{4, dim, T}} where {dim, T}}","page":"API","title":"TensND.KM","text":"KM(t::AbstractTens{order,dim}; kwargs...)\nKM(t::AbstractTens{order,dim}, var::NTuple{order,Symbol}, b::AbstractBasis{dim}; kwargs...)\n\nWrite the components of a second or fourth order tensor in Kelvin-Mandel notation\n\nExamples\n\njulia> σ = Tens(SymmetricTensor{2,3}((i, j) -> symbols(\"σ$i$j\", real = true))) ;\n\njulia> KM(σ)\n6-element Vector{Sym}:\n         σ11\n         σ22\n         σ33\n      √2⋅σ32\n      √2⋅σ31\n      √2⋅σ21\n\njulia> C = Tens(SymmetricTensor{4,3}((i, j, k, l) -> symbols(\"C$i$j$k$l\", real = true))) ;\n\njulia> KM(C)\n6×6 Matrix{Sym}:\n         C₁₁₁₁     C₁₁₂₂     C₁₁₃₃  √2⋅C₁₁₃₂  √2⋅C₁₁₃₁  √2⋅C₁₁₂₁\n         C₂₂₁₁     C₂₂₂₂     C₂₂₃₃  √2⋅C₂₂₃₂  √2⋅C₂₂₃₁  √2⋅C₂₂₂₁\n         C₃₃₁₁     C₃₃₂₂     C₃₃₃₃  √2⋅C₃₃₃₂  √2⋅C₃₃₃₁  √2⋅C₃₃₂₁\n      √2⋅C₃₂₁₁  √2⋅C₃₂₂₂  √2⋅C₃₂₃₃   2⋅C₃₂₃₂   2⋅C₃₂₃₁   2⋅C₃₂₂₁\n      √2⋅C₃₁₁₁  √2⋅C₃₁₂₂  √2⋅C₃₁₃₃   2⋅C₃₁₃₂   2⋅C₃₁₃₁   2⋅C₃₁₂₁\n      √2⋅C₂₁₁₁  √2⋅C₂₁₂₂  √2⋅C₂₁₃₃   2⋅C₂₁₃₂   2⋅C₂₁₃₁   2⋅C₂₁₂₁\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.KM-Union{Tuple{TensISO{order, dim}}, Tuple{dim}, Tuple{order}} where {order, dim}","page":"API","title":"TensND.KM","text":"KM(v::AllIsotropic{dim}; kwargs...)\n\nKelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.LAPLACE-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Sym, Symbolics.Num}}","page":"API","title":"TensND.LAPLACE","text":"LAPLACE(t::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the Laplace operator of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.LAPLACE-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.LAPLACE","text":"LAPLACE(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the Laplace operator of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.LeviCivita","page":"API","title":"TensND.LeviCivita","text":"LeviCivita(T::Type{<:Number} = Sym)\n\nBuilds an Array{T,3} of Levi-Civita Symbol ϵᵢⱼₖ = (i-j) (j-k) (k-i) / 2\n\nExamples\n\njulia> ε = LeviCivita(Sym)\n3×3×3 Array{Sym, 3}:\n[:, :, 1] =\n 0   0  0\n 0   0  1\n 0  -1  0\n\n[:, :, 2] =\n 0  0  -1\n 0  0   0\n 1  0   0\n\n[:, :, 3] =\n  0  1  0\n -1  0  0\n  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.SYMGRAD-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Sym, Symbolics.Num}}","page":"API","title":"TensND.SYMGRAD","text":"SYMGRAD(t::Union{T,AbstractTens{order,dim,T}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the symmetrized gradient of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.SYMGRAD-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.SYMGRAD","text":"SYMGRAD(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the symmetrized gradient of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"API","title":"TensND.angles","text":"angles(M::AbstractMatrix{T})\n\nDetermine the Euler angles corresponding to the input matrix supposed to be a rotation matrix or at least a similarity\n\nExamples\n\njulia> θ, ϕ, ψ = symbols(\"θ, ϕ, ψ\", real = true) ; ℬʳ = RotatedBasis(θ, ϕ, ψ) ; display(vecbasis(ℬʳ, :cov))\n3×3 Tensor{2, 3, Sym, 9}:\n -sin(ψ)⋅sin(ϕ) + cos(θ)⋅cos(ψ)⋅cos(ϕ)  -sin(ψ)⋅cos(θ)⋅cos(ϕ) - sin(ϕ)⋅cos(ψ)  sin(θ)⋅cos(ϕ)\n  sin(ψ)⋅cos(ϕ) + sin(ϕ)⋅cos(θ)⋅cos(ψ)  -sin(ψ)⋅sin(ϕ)⋅cos(θ) + cos(ψ)⋅cos(ϕ)  sin(θ)⋅sin(ϕ)\n                        -sin(θ)⋅cos(ψ)                          sin(θ)⋅sin(ψ)         cos(θ)\n\njulia> angles(ℬʳ)\n(θ = θ, ϕ = ϕ, ψ = ψ)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.change_tens-Tuple{AbstractTens, TensND.AbstractBasis, Tuple{Vararg{T, N}} where {N, T}}","page":"API","title":"TensND.change_tens","text":"change_tens(t::AbstractTens{order,dim,T},ℬ::AbstractBasis{dim},var::NTuple{order,Symbol})\nchange_tens(t::AbstractTens{order,dim,T},ℬ::AbstractBasis{dim})\nchange_tens(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nRewrite the same tensor with components corresponding to new variances and/or to a new basis\n\njulia> ℬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n v₁\n v₂\n v₃\n# basis: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, ℬ, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> ℬ₀ = Basis(Sym[0 1 1; 1 0 1; 1 1 1]) ;\n\njulia> TV0 = change_tens(TV, ℬ₀)\nTens{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n     -v₁ + v₃\n     -v₂ + v₃\n v₁ + v₂ - v₃\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.change_tens_canon-Tuple{AbstractTens}","page":"API","title":"TensND.change_tens_canon","text":"change_tens_canon(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nRewrite the same tensor with components corresponding to the canonical basis\n\njulia> ℬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)), ℬ)\nTens{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n v₁\n v₂\n v₃\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\njulia> TV0 = change_tens_canon(TV)\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n      v₂ + v₃\n      v₁ + v₃\n v₁ + v₂ + v₃\n# basis: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.components-Tuple{AbstractTens}","page":"API","title":"TensND.components","text":"components(t::AbstractTens{order,dim,T},ℬ::AbstractBasis{dim},var::NTuple{order,Symbol})\ncomponents(t::AbstractTens{order,dim,T},ℬ::AbstractBasis{dim})\ncomponents(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nExtract the components of a tensor for new variances and/or in a new basis\n\nExamples\n\njulia> ℬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n v₁\n v₂\n v₃\n# basis: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, ℬ, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> components(TV, ℬ, (:cov,))\n3-element Vector{Sym}:\n v₂ + v₃\n v₁ + v₃\n v₁ + v₂\n\njulia> simplify.(components(TV, normalize(ℬ), (:cov,)))\n3-element Vector{Sym}:\n sqrt(2)*(v2 + v3)/2\n sqrt(2)*(v1 + v3)/2\n sqrt(2)*(v1 + v2)/2\n\njulia> TT = Tens(Tensor{2,3}((i,j)->symbols(\"t$i$j\",real=true)))\nTensND.TensCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3×3 Tensor{2, 3, Sym, 9}:\n t₁₁  t₁₂  t₁₃\n t₂₁  t₂₂  t₂₃\n t₃₁  t₃₂  t₃₃\n# basis: 3×3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont, :cont)\n\njulia> components(TT, ℬ, (:cov,:cov))\n3×3 Matrix{Sym}:\n t₂₂ + t₂₃ + t₃₂ + t₃₃  t₂₁ + t₂₃ + t₃₁ + t₃₃  t₂₁ + t₂₂ + t₃₁ + t₃₂\n t₁₂ + t₁₃ + t₃₂ + t₃₃  t₁₁ + t₁₃ + t₃₁ + t₃₃  t₁₁ + t₁₂ + t₃₁ + t₃₂\n t₁₂ + t₁₃ + t₂₂ + t₂₃  t₁₁ + t₁₃ + t₂₁ + t₂₃  t₁₁ + t₁₂ + t₂₁ + t₂₂\n\njulia> factor.(components(TT, ℬ, (:cont,:cov)))\n3×3 Matrix{Sym}:\n -(t12 + t13 - t22 - t23 - t32 - t33)/2  …  -(t11 + t12 - t21 - t22 - t31 - t32)/2\n  (t12 + t13 - t22 - t23 + t32 + t33)/2      (t11 + t12 - t21 - t22 + t31 + t32)/2\n  (t12 + t13 + t22 + t23 - t32 - t33)/2      (t11 + t12 + t21 + t22 - t31 - t32)/2\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.components_canon-Tuple{AbstractTens}","page":"API","title":"TensND.components_canon","text":"components_canon(t::AbstractTens)\n\nExtract the components of a tensor in the canonical basis\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.contract-Union{Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim}, Integer, Integer}} where {order, dim}","page":"API","title":"TensND.contract","text":"contract(t::AbstractTens{order,dim}, i::Integer, j::Integer)\n\nCalculate the tensor obtained after contraction with respect to the indices i and j\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_cartesian-Union{Tuple{}, Tuple{Tuple{T, T, T}}, Tuple{T}} where T<:Union{Sym, Symbolics.Num}","page":"API","title":"TensND.coorsys_cartesian","text":"coorsys_cartesian(coords = symbols(\"x y z\", real = true))\n\nReturn the cartesian coordinate system\n\nExamples\n\njulia> Cartesian = coorsys_cartesian() ; 𝐗 = getcoords(Cartesian) ; 𝐄 = unitvec(Cartesian) ; ℬ = getbasis(Cartesian)\n\njulia> 𝛔 = Tens(SymmetricTensor{2,3}((i, j) -> SymFunction(\"σ$i$j\", real = true)(𝐗...))) ;\n\njulia> DIV(𝛔, CScar)\nTens.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n Derivative(σ11(x, y, z), x) + Derivative(σ21(x, y, z), y) + Derivative(σ31(x, y, z), z)\n Derivative(σ21(x, y, z), x) + Derivative(σ22(x, y, z), y) + Derivative(σ32(x, y, z), z)\n Derivative(σ31(x, y, z), x) + Derivative(σ32(x, y, z), y) + Derivative(σ33(x, y, z), z)\n# basis: 3×3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_cylindrical-Union{Tuple{}, Tuple{Tuple{T, T, T}}, Tuple{T}} where T<:Union{Sym, Symbolics.Num}","page":"API","title":"TensND.coorsys_cylindrical","text":"coorsys_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"θ\", real = true), symbols(\"z\", real = true)); canonical = false)\n\nReturn the cylindrical coordinate system\n\nExamples\n\njulia> Cylindrical = coorsys_cylindrical() ; rθz = getcoords(Cylindrical) ; 𝐞ʳ, 𝐞ᶿ, 𝐞ᶻ = unitvec(Cylindrical) ; ℬᶜ = getbasis(Cylindrical)\n\njulia> 𝐯 = Tens(Vec{3}(i -> SymFunction(\"v$(rθz[i])\", real = true)(rθz...)), ℬᶜ) ;\n\njulia> DIV(𝐯, Cylindrical)\n                                                  ∂\n                                    vr(r, θ, z) + ──(vθ(r, θ, z))\n∂                 ∂                               ∂θ\n──(vr(r, θ, z)) + ──(vz(r, θ, z)) + ─────────────────────────────\n∂r                ∂z                              r\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_polar-Union{Tuple{}, Tuple{Tuple{T, T}}, Tuple{T}} where T<:Union{Sym, Symbolics.Num}","page":"API","title":"TensND.coorsys_polar","text":"coorsys_polar(coords = (symbols(\"r\", positive = true), symbols(\"θ\", real = true)); canonical = false)\n\nReturn the polar coordinate system\n\nExamples\n\njulia> Polar = coorsys_polar() ; r, θ = getcoords(Polar) ; 𝐞ʳ, 𝐞ᶿ = unitvec(Polar) ; ℬᵖ = getbasis(Polar)\n\njulia> f = SymFunction(\"f\", real = true)(r, θ) ;\n\njulia> LAPLACE(f, Polar)\n                               2\n                              ∂\n                             ───(f(r, θ))\n                               2\n               ∂             ∂θ\n  2            ──(f(r, θ)) + ────────────\n ∂             ∂r                 r\n───(f(r, θ)) + ──────────────────────────\n  2                        r\n∂r\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_spherical-Union{Tuple{}, Tuple{Tuple{T, T, T}}, Tuple{T}} where T<:Union{Sym, Symbolics.Num}","page":"API","title":"TensND.coorsys_spherical","text":"coorsys_spherical(coords = (symbols(\"θ\", real = true), symbols(\"ϕ\", real = true), symbols(\"r\", positive = true)); canonical = false)\n\nReturn the spherical coordinate system\n\nExamples\n\njulia> Spherical = coorsys_spherical() ; θ, ϕ, r = getcoords(Spherical) ; 𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ = unitvec(Spherical) ; ℬˢ = getbasis(Spherical)\n\njulia> for σⁱʲ ∈ (\"σʳʳ\", \"σᶿᶿ\", \"σᵠᵠ\") @eval $(Symbol(σⁱʲ)) = SymFunction($σⁱʲ, real = true)($r) end ;\n\njulia> 𝛔 = σʳʳ * 𝐞ʳ ⊗ 𝐞ʳ + σᶿᶿ * 𝐞ᶿ ⊗ 𝐞ᶿ + σᵠᵠ * 𝐞ᵠ ⊗ 𝐞ᵠ ;\n\njulia> div𝛔 = DIV(𝛔, Spherical)\nTens.TensRotated{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n                              (-σᵠᵠ(r) + σᶿᶿ(r))*cos(θ)/(r*sin(θ))\n                                                                 0\n Derivative(σʳʳ(r), r) + (σʳʳ(r) - σᵠᵠ(r))/r + (σʳʳ(r) - σᶿᶿ(r))/r\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n cos(θ)⋅cos(ϕ)  -sin(ϕ)  sin(θ)⋅cos(ϕ)\n sin(ϕ)⋅cos(θ)   cos(ϕ)  sin(θ)⋅sin(ϕ)\n       -sin(θ)        0         cos(θ)\n# var: (:cont,)\n\njulia> div𝛔 ⋅ 𝐞ʳ\nd            σʳʳ(r) - σᵠᵠ(r)   σʳʳ(r) - σᶿᶿ(r)\n──(σʳʳ(r)) + ─────────────── + ───────────────\ndr                  r                 r\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_spheroidal-Union{Tuple{}, Tuple{Tuple{T, T, T}}, Tuple{T}, Tuple{Tuple{T, T, T}, Any}, Tuple{Tuple{T, T, T}, Any, Any}} where T<:Union{Sym, Symbolics.Num}","page":"API","title":"TensND.coorsys_spheroidal","text":"coorsys_spheroidal(coords = (symbols(\"ϕ\", real = true),symbols(\"p\", real = true),symbols(\"q\", positive = true),),\n                        c = symbols(\"c\", positive = true),tmp_coords = (symbols(\"p̄ q̄\", positive = true)...,),)\n\nReturn the spheroidal coordinate system\n\nExamples\n\njulia> Spheroidal = coorsys_spheroidal() ; OM = getOM(Spheroidal)\nTens.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n c⋅p̄⋅q̄⋅cos(ϕ)\n c⋅p̄⋅q̄⋅sin(ϕ)\n          c⋅p⋅q\n# basis: 3×3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> LAPLACE(OM[1]^2, Spheroidal)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.init_cartesian","page":"API","title":"TensND.init_cartesian","text":"init_cartesian(coords = symbols(\"x y z\", real = true))\n\nReturns the coordinates, unit vectors and basis of the cartesian basis\n\nExamples\n\njulia> coords, vectors, ℬ = init_cartesian() ; x, y, z = coords ; 𝐞₁, 𝐞₂, 𝐞₃ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_cylindrical","page":"API","title":"TensND.init_cylindrical","text":"init_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"θ z\", real = true)...); canonical = false)\n\nReturns the coordinates, base vectors and basis of the cylindrical basis\n\nExamples\n\njulia> coords, vectors, ℬᶜ = init_cylindrical() ; r, θ, z = coords ; 𝐞ʳ, 𝐞ᶿ, 𝐞ᶻ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_polar","page":"API","title":"TensND.init_polar","text":"init_polar(coords = (symbols(\"r θ\", real = true)); canonical = false)\n\nReturns the coordinates, base vectors and basis of the polar basis\n\nExamples\n\njulia> coords, vectors, ℬᵖ = init_polar() ; r, θ = coords ; 𝐞ʳ, 𝐞ᶿ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_rotated","page":"API","title":"TensND.init_rotated","text":"init_rotated(coords = symbols(\"θ ϕ ψ\", real = true); canonical = false)\n\nReturn the angles, base vectors and basis of the rotated basis. Note that here the coordinates are angles and do not represent a valid parametrization of ℝ³\n\nExamples\n\njulia> angles, vectors, ℬʳ = init_rotated() ; θ, ϕ, ψ = angles ; 𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_spherical","page":"API","title":"TensND.init_spherical","text":"init_spherical(coords = (symbols(\"θ ϕ\", real = true)..., symbols(\"r\", positive = true)); canonical = false)\n\nReturn the coordinates, base vectors and basis of the spherical basis. Take care that the order of the 3 vectors is 𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ so that the basis coincides with the canonical one when the angles are null and in consistency the coordinates are ordered as θ, ϕ, r.\n\nExamples\n\njulia> coords, vectors, ℬˢ = init_spherical() ; θ, ϕ, r = coords ; 𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ  = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.invKM-Tuple{Type{<:Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T}, Tensors.SymmetricTensor{4, dim, T}, Tensors.Tensor{2, dim, T}, Tensors.Tensor{4, dim, T}} where {dim, T}}, AbstractVecOrMat}","page":"API","title":"TensND.invKM","text":"invKM(v::AbstractVecOrMat; kwargs...)\n\nDefine a tensor from a Kelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.isorthogonal-Tuple{TensND.AbstractBasis}","page":"API","title":"TensND.isorthogonal","text":"isorthogonal(ℬ::AbstractBasis)\n\nCheck whether the basis ℬ is orthogonal\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.isorthonormal-Tuple{TensND.AbstractBasis}","page":"API","title":"TensND.isorthonormal","text":"isorthonormal(ℬ::AbstractBasis)\n\nCheck whether the basis ℬ is orthonormal\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.metric-Tuple{TensND.AbstractBasis, Val{:cov}}","page":"API","title":"TensND.metric","text":"metric(ℬ::AbstractBasis, var = :cov)\n\nReturn the covariant (if var = :cov) or contravariant (if var = :cont) metric matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"TensND.otimesul","text":"otimesul(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a special tensor product between two tensors of at least second order\n\n(𝐚 ⊠ˢ 𝐛) ⊡ 𝐩 = (𝐚 ⊠ 𝐛) ⊡ (𝐩 + ᵗ𝐩)/2  = 1/2(aⁱᵏbʲˡ+aⁱˡbʲᵏ) pₖₗ eᵢ⊗eⱼ\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.qcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"TensND.qcontract","text":"qcontract(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a quadruple contracted product between two tensors\n\n𝔸 ⊙ 𝔹 = AᵢⱼₖₗBⁱʲᵏˡ\n\nExamples\n\njulia> 𝕀 = t𝕀(Sym) ; 𝕁 = t𝕁(Sym) ; 𝕂 = t𝕂(Sym) ;\n\njulia> 𝕀 ⊙ 𝕀\n6\n\njulia> 𝕁 ⊙ 𝕀\n1\n\njulia> 𝕂 ⊙ 𝕀\n5\n\njulia> 𝕂 ⊙ 𝕁\n0\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.rot2-Tuple{Any}","page":"API","title":"TensND.rot2","text":"rot2(θ)\n\nReturn a 2D rotation matrix with respect to the angle θ\n\nExamples\n\njulia> rot2(θ)\n2×2 Tensor{2, 2, Sym, 4}:\n cos(θ)  -sin(θ)\n sin(θ)   cos(θ)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.rot3","page":"API","title":"TensND.rot3","text":"rot3(θ, ϕ = 0, ψ = 0)\n\nReturn a rotation matrix with respect to the 3 Euler angles θ, ϕ, ψ\n\nExamples\n\njulia> cθ, cϕ, cψ, sθ, sϕ, sψ = symbols(\"cθ cϕ cψ sθ sϕ sψ\", real = true) ;\n\njulia> d = Dict(cos(θ) => cθ, cos(ϕ) => cϕ, cos(ψ) => cψ, sin(θ) => sθ, sin(ϕ) => sϕ, sin(ψ) => sψ) ;\n\njulia> subs.(rot3(θ, ϕ, ψ),d...)\n3×3 StaticArrays.SMatrix{3, 3, Sym, 9} with indices SOneTo(3)×SOneTo(3):\n cθ⋅cψ⋅cϕ - sψ⋅sϕ  -cθ⋅cϕ⋅sψ - cψ⋅sϕ  cϕ⋅sθ\n cθ⋅cψ⋅sϕ + cϕ⋅sψ  -cθ⋅sψ⋅sϕ + cψ⋅cϕ  sθ⋅sϕ\n           -cψ⋅sθ              sθ⋅sψ     cθ\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.rot6","page":"API","title":"TensND.rot6","text":"rot6(θ, ϕ = 0, ψ = 0)\n\nReturn a rotation matrix with respect to the 3 Euler angles θ, ϕ, ψ\n\nExamples\n\njulia> cθ, cϕ, cψ, sθ, sϕ, sψ = symbols(\"cθ cϕ cψ sθ sϕ sψ\", real = true) ;\n\njulia> d = Dict(cos(θ) => cθ, cos(ϕ) => cϕ, cos(ψ) => cψ, sin(θ) => sθ, sin(ϕ) => sϕ, sin(ψ) => sψ) ;\n\njulia> R = Tens(subs.(rot3(θ, ϕ, ψ),d...))\nTens.TensCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3×3 Tensor{2, 3, Sym, 9}:\n cθ⋅cψ⋅cϕ - sψ⋅sϕ  -cθ⋅cϕ⋅sψ - cψ⋅sϕ  cϕ⋅sθ\n cθ⋅cψ⋅sϕ + cϕ⋅sψ  -cθ⋅sψ⋅sϕ + cψ⋅cϕ  sθ⋅sϕ\n           -cψ⋅sθ              sθ⋅sψ     cθ\n# var: (:cont, :cont)\n# basis: 3×3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> RR = R ⊠ˢ R\nTens.TensCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6×6 Matrix{Sym}:\n                          (cθ*cψ*cϕ - sψ*sϕ)^2                            (-cθ*cϕ*sψ - cψ*sϕ)^2           cϕ^2*sθ^2                      √2⋅cϕ⋅sθ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)                     √2⋅cϕ⋅sθ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)                                   √2⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)\n                          (cθ*cψ*sϕ + cϕ*sψ)^2                            (-cθ*sψ*sϕ + cψ*cϕ)^2           sθ^2*sϕ^2                      √2⋅sθ⋅sϕ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)                     √2⋅sθ⋅sϕ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)                                   √2⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)\n                                     cψ^2*sθ^2                                        sθ^2*sψ^2                cθ^2                                       √2⋅cθ⋅sθ⋅sψ                                    -√2⋅cθ⋅cψ⋅sθ                                                              -sqrt(2)*cψ*sθ^2*sψ\n             -√2⋅cψ⋅sθ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)                √2⋅sθ⋅sψ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)    √2⋅cθ⋅sθ⋅sϕ                    cθ*(-cθ*sψ*sϕ + cψ*cϕ) + sθ^2*sψ*sϕ                   cθ*(cθ*cψ*sϕ + cϕ*sψ) - cψ*sθ^2*sϕ                            -cψ⋅sθ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ) + sθ⋅sψ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)\n             -√2⋅cψ⋅sθ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)                √2⋅sθ⋅sψ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)    √2⋅cθ⋅cϕ⋅sθ                    cθ*(-cθ*cϕ*sψ - cψ*sϕ) + cϕ*sθ^2*sψ                   cθ*(cθ*cψ*cϕ - sψ*sϕ) - cψ*cϕ*sθ^2                            -cψ⋅sθ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ) + sθ⋅sψ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)\n √2⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)  √2⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)  sqrt(2)*cϕ*sθ^2*sϕ  cϕ⋅sθ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ) + sθ⋅sϕ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)  cϕ⋅sθ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ) + sθ⋅sϕ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)  (cθ*cψ*cϕ - sψ*sϕ)*(-cθ*sψ*sϕ + cψ*cϕ) + (cθ*cψ*sϕ + cϕ*sψ)*(-cθ*cϕ*sψ - cψ*sϕ)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3×3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 = invKM(subs.(KM(rot6(θ, ϕ, ψ)),d...))\nTens.TensCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6×6 Matrix{Sym}:\n                          (cθ*cψ*cϕ - sψ*sϕ)^2                            (-cθ*cϕ*sψ - cψ*sϕ)^2           cϕ^2*sθ^2                      √2⋅cϕ⋅sθ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)                     √2⋅cϕ⋅sθ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)                                   √2⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)\n                          (cθ*cψ*sϕ + cϕ*sψ)^2                            (-cθ*sψ*sϕ + cψ*cϕ)^2           sθ^2*sϕ^2                      √2⋅sθ⋅sϕ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)                     √2⋅sθ⋅sϕ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)                                   √2⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)\n                                     cψ^2*sθ^2                                        sθ^2*sψ^2                cθ^2                                       √2⋅cθ⋅sθ⋅sψ                                    -√2⋅cθ⋅cψ⋅sθ                                                              -sqrt(2)*cψ*sθ^2*sψ\n             -√2⋅cψ⋅sθ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)                √2⋅sθ⋅sψ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)    √2⋅cθ⋅sθ⋅sϕ                    cθ*(-cθ*sψ*sϕ + cψ*cϕ) + sθ^2*sψ*sϕ                   cθ*(cθ*cψ*sϕ + cϕ*sψ) - cψ*sθ^2*sϕ                            -cψ⋅sθ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ) + sθ⋅sψ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)\n             -√2⋅cψ⋅sθ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)                √2⋅sθ⋅sψ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)    √2⋅cθ⋅cϕ⋅sθ                    cθ*(-cθ*cϕ*sψ - cψ*sϕ) + cϕ*sθ^2*sψ                   cθ*(cθ*cψ*cϕ - sψ*sϕ) - cψ*cϕ*sθ^2                            -cψ⋅sθ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ) + sθ⋅sψ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)\n √2⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ)  √2⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ)  sqrt(2)*cde Liv Lehn ϕ*sθ^2*sϕ  cϕ⋅sθ⋅(-cθ⋅sψ⋅sϕ + cψ⋅cϕ) + sθ⋅sϕ⋅(-cθ⋅cϕ⋅sψ - cψ⋅sϕ)  cϕ⋅sθ⋅(cθ⋅cψ⋅sϕ + cϕ⋅sψ) + sθ⋅sϕ⋅(cθ⋅cψ⋅cϕ - sψ⋅sϕ)  (cθ*cψ*cϕ - sψ*sϕ)*(-cθ*sψ*sϕ + cψ*cϕ) + (cθ*cψ*sϕ + cϕ*sψ)*(-cθ*cϕ*sψ - cψ*sϕ)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3×3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 == RR\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"TensND.sotimes","text":"sotimes(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a symmetric tensor product between two tensors\n\n(aⁱeᵢ) ⊗ˢ (bʲeⱼ) = 1/2(aⁱbʲ + aʲbⁱ) eᵢ⊗eⱼ\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensId2-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensId2","text":"tensId2(::Val{dim}, ::Val{T}) where {dim,T<:Number}\n\nIdentity tensor of second order 𝟏ᵢⱼ = δᵢⱼ = 1 if i=j otherwise 0\n\nExamples\n\njulia> 𝟏 = t𝟏() ; KM(𝟏)\n6-element Vector{Sym}:\n 1\n 1\n 1\n 0\n 0\n 0\n\njulia> 𝟏.data\n3×3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensId4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensId4","text":"tensId4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nSymmetric identity tensor of fourth order  𝕀 = 𝟏 ⊠ˢ 𝟏 i.e. (𝕀)ᵢⱼₖₗ = (δᵢₖδⱼₗ+δᵢₗδⱼₖ)/2\n\nExamples\n\njulia> 𝕀 = t𝕀() ; KM(𝕀)\n6×6 Matrix{Sym}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  0  1  0  0\n 0  0  0  0  1  0\n 0  0  0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensJ4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensJ4","text":"tensJ4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nSpherical projector of fourth order  𝕁 = (𝟏 ⊗ 𝟏) / dim i.e. (𝕁)ᵢⱼₖₗ = δᵢⱼδₖₗ/dim\n\nExamples\n\njulia> 𝕁 = t𝕁() ; KM(𝕁)\n6×6 Matrix{Sym}:\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensK4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensK4","text":"tensK4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nDeviatoric projector of fourth order  𝕂 = 𝕀 - 𝕁 i.e. (𝕂)ᵢⱼₖₗ = (δᵢₖδⱼₗ+δᵢₗδⱼₖ)/2 - δᵢⱼδₖₗ/dim\n\nExamples\n\njulia> 𝕂 = t𝕂() ; KM(𝕂)\n6×6 Matrix{Sym}:\n  2/3  -1/3  -1/3  0  0  0\n -1/3   2/3  -1/3  0  0  0\n -1/3  -1/3   2/3  0  0  0\n    0     0     0  1  0  0\n    0     0     0  0  1  0\n    0     0     0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.vecbasis-Tuple{TensND.AbstractBasis, Val{:cov}}","page":"API","title":"TensND.vecbasis","text":"vecbasis(ℬ::AbstractBasis, var = :cov)\n\nReturn the primal (if var = :cov) or dual (if var = :cont) basis\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.∂-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, T}, Vararg{Any}}} where {order, dim, T<:Union{Sym, Symbolics.Num}}","page":"API","title":"TensND.∂","text":"∂(t::AbstractTens{order,dim,T,A},xᵢ::T)\n\nReturn the derivative of the tensor t with respect to the variable x_i\n\nExamples\n\n\njulia> (θ, ϕ, r), (𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ), ℬˢ = init_spherical() ;\n\njulia> ∂(𝐞ʳ, ϕ) == sin(θ) * 𝐞ᵠ\ntrue\n\njulia> ∂(𝐞ʳ ⊗ 𝐞ʳ,θ)\nTens.TensRotated{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3×3 SymmetricTensor{2, 3, Sym, 6}:\n 0  0  1\n 0  0  0\n 1  0  0\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n cos(θ)⋅cos(ϕ)  -sin(ϕ)  sin(θ)⋅cos(ϕ)\n sin(ϕ)⋅cos(θ)   cos(ϕ)  sin(θ)⋅sin(ϕ)\n       -sin(θ)        0         cos(θ)\n# var: (:cont, :cont)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.𝐞-Union{Tuple{Val{i}}, Tuple{T}, Tuple{dim}, Tuple{i}, Tuple{Val{i}, Val{dim}}, Tuple{Val{i}, Val{dim}, Val{T}}} where {i, dim, T<:Number}","page":"API","title":"TensND.𝐞","text":"𝐞(i::Integer, dim::Int = 3, T::Type{<:Number} = Sym)\n\nVector of the canonical basis\n\nExamples\n\njulia> 𝐞(1)\nTens{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.𝐞ˢ-Union{Tuple{Val{1}}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Val{1}, T1}, Tuple{Val{1}, T1, T2}, Tuple{Val{1}, T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"API","title":"TensND.𝐞ˢ","text":"𝐞ˢ(i::Integer, θ::T = zero(Sym), ϕ::T = zero(Sym), ψ::T = zero(Sym); canonical = false)\n\nVector of the basis rotated with the 3 Euler angles θ, ϕ, ψ (spherical if ψ=0)\n\nExamples\n\njulia> θ, ϕ, ψ = symbols(\"θ, ϕ, ψ\", real = true) ;\n\nTens{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n -sin(ψ)⋅sin(ϕ) + cos(θ)⋅cos(ψ)⋅cos(ϕ)  -sin(ψ)⋅cos(θ)⋅cos(ϕ) - sin(ϕ)⋅cos(ψ)  sin(θ)⋅cos(ϕ)\n  sin(ψ)⋅cos(ϕ) + sin(ϕ)⋅cos(θ)⋅cos(ψ)  -sin(ψ)⋅sin(ϕ)⋅cos(θ) + cos(ψ)⋅cos(ϕ)  sin(θ)⋅sin(ϕ)\n                        -sin(θ)⋅cos(ψ)                          sin(θ)⋅sin(ψ)         cos(θ)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.𝐞ᵖ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"API","title":"TensND.𝐞ᵖ","text":"𝐞ᵖ(i::Integer, θ::T = zero(Sym); canonical = false)\n\nVector of the polar basis\n\nExamples\n\njulia> θ = symbols(\"θ\", real = true) ;\n\njulia> 𝐞ᵖ(1, θ)\nTens{1, 2, Sym, Sym, Vec{2, Sym}, RotatedBasis{2, Sym}}\n# data: 2-element Vec{2, Sym}:\n 1\n 0\n# var: (:cont,)\n# basis: 2×2 Tensor{2, 2, Sym, 4}:\n cos(θ)  -sin(θ)\n sin(θ)   cos(θ)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.𝐞ᶜ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"API","title":"TensND.𝐞ᶜ","text":"𝐞ᶜ(i::Integer, θ::T = zero(Sym); canonical = false)\n\nVector of the cylindrical basis\n\nExamples\n\njulia> θ = symbols(\"θ\", real = true) ;\n\njulia> 𝐞ᶜ(1, θ)\nTens{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n cos(θ)  -sin(θ)  0\n sin(θ)   cos(θ)  0\n      0        0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"Tensors.dcontract","text":"dcontract(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a double contracted product between two tensors\n\n𝛔 ⊡ 𝛆 = σⁱʲεᵢⱼ 𝛔 = ℂ ⊡ 𝛆\n\nExamples\n\njulia> 𝛆 = Tens(SymmetricTensor{2,3}((i, j) -> symbols(\"ε$i$j\", real = true))) ;\n\njulia> k, μ = symbols(\"k μ\", real =true) ;\n\njulia> ℂ = 3k * t𝕁() + 2μ * t𝕂() ;\n\njulia> 𝛔 = ℂ ⊡ 𝛆\nTens{2, 3, Sym, Sym, SymmetricTensor{2, 3, Sym, 6}, CanonicalBasis{3, Sym}}\n# data: 3×3 SymmetricTensor{2, 3, Sym, 6}:\n ε11*(k + 4*μ/3) + ε22*(k - 2*μ/3) + ε33*(k - 2*μ/3)                                              2⋅ε21⋅μ                                              2⋅ε31⋅μ\n                                             2⋅ε21⋅μ  ε11*(k - 2*μ/3) + ε22*(k + 4*μ/3) + ε33*(k - 2*μ/3)                                              2⋅ε32⋅μ\n                                             2⋅ε31⋅μ                                              2⋅ε32⋅μ  ε11*(k - 2*μ/3) + ε22*(k - 2*μ/3) + ε33*(k + 4*μ/3)\n# var: (:cont, :cont)\n# basis: 3×3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{orderS, dim}, AbstractTens{order2, dim}}} where {order1, orderS, order2, dim}","page":"API","title":"Tensors.dotdot","text":"dotdot(v1::AbstractTens{order1,dim}, S::AbstractTens{orderS,dim}, v2::AbstractTens{order2,dim})\n\nDefine a bilinear operator 𝐯₁⋅𝕊⋅𝐯₂\n\nExamples\n\njulia> n = Tens(Sym[0, 0, 1]) ;\n\njulia> k, μ = symbols(\"k μ\", real =true) ;\n\njulia> ℂ = 3k * t𝕁() + 2μ * t𝕂() ;\n\njulia> dotdot(n,ℂ,n) # Acoustic tensor\n3×3 Tens{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}:\n μ  0          0\n 0  μ          0\n 0  0  k + 4*μ/3\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"Tensors.otimes","text":"otimes(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a tensor product between two tensors\n\n(aⁱeᵢ) ⊗ (bʲeⱼ) = aⁱbʲ eᵢ⊗eⱼ\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"Tensors.otimesu","text":"otimesu(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a special tensor product between two tensors of at least second order\n\n(𝐚 ⊠ 𝐛) ⊡ 𝐩 = 𝐚⋅𝐩⋅𝐛 = aⁱᵏbʲˡpₖₗ eᵢ⊗eⱼ\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.@set_coorsys","page":"API","title":"TensND.@set_coorsys","text":"@set_coorsys CS\n@set_coorsys(CS)\n\nSet a coordinate system in order to avoid precising it in differential operators\n\nExamples\n\njulia> Spherical = coorsys_spherical() ; θ, ϕ, r = getcoords(Spherical) ; 𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ = unitvec(Spherical) ; vec = (\"𝐞ᶿ\", \"𝐞ᵠ\", \"𝐞ʳ\") ;\n\njulia> @set_coorsys Spherical\n\njulia> intrinsic(GRAD(𝐞ʳ),vec)\n(1/r)𝐞ᶿ⊗𝐞ᶿ + (1/r)𝐞ᵠ⊗𝐞ᵠ\n\njulia> intrinsic(DIV(𝐞ʳ ⊗ 𝐞ʳ),vec)\n(2/r)𝐞ʳ\n\njulia> LAPLACE(1/r)\n0\n\n\n\n\n\n","category":"macro"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"tuto/nlayersphere/#N-layer-sphere","page":"N-layer sphere","title":"N-layer sphere","text":"","category":"section"},{"location":"tuto/nlayersphere/","page":"N-layer sphere","title":"N-layer sphere","text":"using TensND, LinearAlgebra, SymPy, Tensors, OMEinsum, Rotations\nsympy.init_printing(use_unicode=true)\n\nSpherical = coorsys_spherical()\nθ, ϕ, r = getcoords(Spherical)\n𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ = unitvec(Spherical)\nℬˢ = normalized_basis(Spherical)\n𝐱 = getOM(Spherical)\n𝐞₁, 𝐞₂, 𝐞₃ = unitvec(coorsys_cartesian())\n𝕀, 𝕁, 𝕂 = ISO(Val(3),Val(Sym))\n𝟏 = tensId2(Val(3),Val(Sym))\nk, μ = symbols(\"k μ\", positive = true)\nλ = k -2μ/3\n\nu = SymFunction(\"u\", real = true)\n𝐮ˢᵖʰ = u(r) * 𝐞ʳ\n𝛆ˢᵖʰ = SYMGRAD(𝐮ˢᵖʰ, Spherical)\n𝛔ˢᵖʰ = λ * tr(𝛆ˢᵖʰ) * 𝟏 + 2μ * 𝛆ˢᵖʰ\n𝐓ˢᵖʰ = 𝛔ˢᵖʰ ⋅ 𝐞ʳ\ndiv𝛔ˢᵖʰ = DIV(𝛔ˢᵖʰ, Spherical) ;\neqˢᵖʰ = factor(simplify(div𝛔ˢᵖʰ ⋅ 𝐞ʳ))\nsolˢᵖʰ = dsolve(eqˢᵖʰ, u(r))\nûˢᵖʰ = solˢᵖʰ.rhs()\nT̂ˢᵖʰ = factor(simplify(subs(𝐓ˢᵖʰ ⋅ 𝐞ʳ, u(r) => ûˢᵖʰ)))\n\n𝐄 = 𝟏 - 3𝐞₃⊗𝐞₃\nfᶿ = simplify(𝐞ᶿ ⋅ 𝐄 ⋅ 𝐞ʳ)\nfʳ = simplify(𝐞ʳ ⋅ 𝐄 ⋅ 𝐞ʳ)\nuᶿ = SymFunction(\"uᶿ\", real = true)\nuʳ = SymFunction(\"uʳ\", real = true)\n𝐮ᵈᵉᵛ = uᶿ(r) * fᶿ * 𝐞ᶿ + uʳ(r) * fʳ * 𝐞ʳ\n𝛆ᵈᵉᵛ = SYMGRAD(𝐮ᵈᵉᵛ, Spherical)\n𝛔ᵈᵉᵛ = λ * tr(𝛆ᵈᵉᵛ) * 𝟏 + 2μ * 𝛆ᵈᵉᵛ\n𝐓ᵈᵉᵛ = 𝛔ᵈᵉᵛ ⋅ 𝐞ʳ\ndiv𝛔ᵈᵉᵛ = simplify(DIV(𝛔ᵈᵉᵛ, Spherical))\neqᶿᵈᵉᵛ = factor(simplify(div𝛔ᵈᵉᵛ ⋅ 𝐞ᶿ / fᶿ))\neqʳᵈᵉᵛ = factor(simplify(div𝛔ᵈᵉᵛ ⋅ 𝐞ʳ / fʳ))\nα, Λ = symbols(\"α Λ\", real = true)\neqᵈᵉᵛ = factor(simplify(subs([eqᶿᵈᵉᵛ,eqʳᵈᵉᵛ], uᶿ(r) => r^α, uʳ(r) => Λ*r^α)))\nαΛ = solve([eq.doit() for eq ∈ eqᵈᵉᵛ], [α, Λ])\nûᶿᵈᵉᵛ = sum([Sym(\"C$(i+2)\") * r^αΛ[i][1] for i ∈ 1:length(αΛ)])\nûʳᵈᵉᵛ = sum([Sym(\"C$(i+2)\") * αΛ[i][2] * r^αΛ[i][1] for i ∈ 1:length(αΛ)])\nT̂ᶿᵈᵉᵛ = factor(simplify(subs(simplify(𝐓ᵈᵉᵛ ⋅ 𝐞ᶿ / fᶿ), uᶿ(r) => ûᶿᵈᵉᵛ, uʳ(r) => ûʳᵈᵉᵛ)))\nT̂ʳᵈᵉᵛ = factor(simplify(subs(simplify(𝐓ᵈᵉᵛ ⋅ 𝐞ʳ / fʳ), uᶿ(r) => ûᶿᵈᵉᵛ, uʳ(r) => ûʳᵈᵉᵛ)))","category":"page"},{"location":"man/coorsystems/#Coordinate-systems-and-differential-operators","page":"Coordinate systems and differential operators","title":"Coordinate systems and differential operators","text":"","category":"section"},{"location":"man/coorsystems/","page":"Coordinate systems and differential operators","title":"Coordinate systems and differential operators","text":"For the moment only symbolic coordinate systems are available. Their numerical counterpart will be later developed. ","category":"page"},{"location":"man/coorsystems/","page":"Coordinate systems and differential operators","title":"Coordinate systems and differential operators","text":"julia> Polar = coorsys_polar() ; r, θ = getcoords(Polar) ; 𝐞ʳ, 𝐞ᶿ = unitvec(Polar) ;\n\njulia> @set_coorsys Polar\n\njulia> LAPLACE(SymFunction(\"f\", real = true)(r, θ))\n                               2\n                              ∂\n               ∂             ───(f(r, θ))\n  2            ──(f(r, θ))     2\n ∂             ∂r            ∂θ\n───(f(r, θ)) + ─────────── + ────────────\n  2                 r              2\n∂r                                r\n\njulia> n = symbols(\"n\", integer = true)\nn\n\njulia> simplify(HESS(r^n))\n(n*r^(n - 2)*(n - 1))𝐞ʳ⊗𝐞ʳ + (n*r^(n - 2))𝐞ᶿ⊗𝐞ᶿ","category":"page"},{"location":"man/coorsystems/","page":"Coordinate systems and differential operators","title":"Coordinate systems and differential operators","text":"julia> Spherical = coorsys_spherical() ; θ, ϕ, r = getcoords(Spherical) ; 𝐞ᶿ, 𝐞ᵠ, 𝐞ʳ = unitvec(Spherical) ;\n\njulia> @set_coorsys Spherical\n\njulia> getChristoffel(Spherical)\n3×3×3 Array{Sym, 3}:\n[:, :, 1] =\n   0               0  1/r\n   0  -sin(θ)⋅cos(θ)    0\n 1/r               0    0\n\n[:, :, 2] =\n             0  cos(θ)/sin(θ)    0\n cos(θ)/sin(θ)              0  1/r\n             0            1/r    0\n\n[:, :, 3] =\n -r            0  0\n  0  -r*sin(θ)^2  0\n  0            0  0\n\njulia> ℬˢ = normalized_basis(Spherical)\nRotatedBasis{3, Sym}\n→ basis: 3×3 Matrix{Sym}:\n cos(θ)⋅cos(ϕ)  -sin(ϕ)  sin(θ)⋅cos(ϕ)\n sin(ϕ)⋅cos(θ)   cos(ϕ)  sin(θ)⋅sin(ϕ)\n       -sin(θ)        0         cos(θ)\n→ dual basis: 3×3 Matrix{Sym}:\n cos(θ)⋅cos(ϕ)  -sin(ϕ)  sin(θ)⋅cos(ϕ)\n sin(ϕ)⋅cos(θ)   cos(ϕ)  sin(θ)⋅sin(ϕ)\n       -sin(θ)        0         cos(θ)\n→ covariant metric tensor: 3×3 TensND.Id2{3, Sym}:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1\n→ contravariant metric tensor: 3×3 TensND.Id2{3, Sym}:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1\n\njulia> for σⁱʲ ∈ (\"σʳʳ\", \"σᶿᶿ\", \"σᵠᵠ\") @eval $(Symbol(σⁱʲ)) = SymFunction($σⁱʲ, real = true)($r) end\n\njulia> 𝛔 = σʳʳ * 𝐞ʳ ⊗ 𝐞ʳ + σᶿᶿ * 𝐞ᶿ ⊗ 𝐞ᶿ + σᵠᵠ * 𝐞ᵠ ⊗ 𝐞ᵠ\n(σᶿᶿ(r))𝐞ᶿ⊗𝐞ᶿ + (σᵠᵠ(r))𝐞ᵠ⊗𝐞ᵠ + (σʳʳ(r))𝐞ʳ⊗𝐞ʳ\n\njulia> div𝛔 = simplify(DIV(𝛔))\n((-σᵠᵠ(r) + σᶿᶿ(r))/(r*tan(θ)))𝐞ᶿ + ((r*Derivative(σʳʳ(r), r) + 2*σʳʳ(r) - σᵠᵠ(r) - σᶿᶿ(r))/r)𝐞ʳ","category":"page"},{"location":"man/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/#Brief-description-of-the-package","page":"Getting started","title":"Brief description of the package","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The package relies on the definition of","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"bases which can be of the following types (T denotes the scalar type, subtype of Number)\nCanonicalBasis{dim,T}: fundamental canonical basis in ℝᵈⁱᵐ in which the metric tensor is the second-order identity\nRotatedBasis{dim,T}: orthonormal basis in ℝᵈⁱᵐ obtained by rotation of the canonical basis by means of one angle if dim=2 or three Euler angles if dim=3, the metric tensor is again the second-order identity\nOrthogonalBasis{dim,T}: orthogonal basis in ℝᵈⁱᵐ obtained from a given orthonormal rotated basis by applying a scaling factor along each unit vector, the metric tensor is then diagonal\nBasis{dim,T}: arbitrary basis not entering the previous cases\ntensors\na tensor is determined by a set of data (array or synthetic parameters) corresponding to its order, a basis and a tuple of variances\ndepending on the type of basis, the type of tensor can be TensCanonical{order,dim,T,A}, TensRotated{order,dim,T,A}, TensOrthogonal{order,dim,T,A} or Tens{order,dim,T,A} if the data are stored under the form of an array or a Tensor object (see Tensors.jl), or the type can be TensISO{order,dim,T,N} if the tensor is isotropic and data are stored under the form of a set of parameters (one for order 2 and two for order 4).\nNOTE:     More material symmetry types such as transverse isotropy or orthotropy will be added in the future.\ncoordinate systems\na coordinate system contains all information required to perform differential operations on tensor fields: position vector OM expressed in the canonical basis, coordinate names xⁱ, natural basis aᵢ=∂ᵢOM, normalized basis eᵢ=aᵢ/||aᵢ||, Christoffel coefficients Γᵢⱼᵏ=∂ᵢaⱼ⋅aᵏ where (aⁱ)(1≤i≤dim) form the dual basis associated to the natural one\npredefined coordinate systems are available: cartesian, polar, cylindrical, spherical and spheroidal but the user can define new systems\nNOTE:     Note that for the moment the coordinate systems and differential operators have been implemented only for symbolic calculations (using SymPy.jl). Numerical coordinate systems and differential operators based on automatic differentiation will be implemented in the future.","category":"page"},{"location":"man/getting_started/#Detailed-manual","page":"Getting started","title":"Detailed manual","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Before detailing explanations about the main features of TensND, it is worth recalling that the use of the libraries TensND and SymPy requires starting scripts by","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> using TensND, SymPy","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The detailed manual is decomposed into the following chapters","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Pages = [\n    \"bases.md\",\n    \"tensors.md\",\n    \"coorsystems.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensND","category":"page"},{"location":"#Documentation-for-[TensND](https://github.com/jfbarthelemy/TensND.jl)","page":"Home","title":"Documentation for TensND","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Package allowing tensor calculations in arbitrary coordinate systems.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package provides tools to perform tensor calculations of any order and any dimension in arbitrary coordinate systems (cartesian, polar, cylindrical, spherical, spheroidal or any user defined coordinate systems...). In particular differential operators are available: gradient, symmetrized gradient, divergence, Laplace, Hessian. The implementation of this library is much inspired by the Maple library Tens3d developed by Jean Garrigues.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/jfbarthelemy/TensND.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"https://github.com/jfbarthelemy/TensND.jl.git\")","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/getting_started.md\",\n    \"man/bases.md\",\n    \"man/tensors.md\",\n    \"man/coorsystems.md\",\n]\nDepth = 1","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tuto/nlayersphere.md\",\n]\nDepth = 1","category":"page"},{"location":"#Citing-TensND.jl","page":"Home","title":"Citing TensND.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@misc{TensND.jl,\n  author  = {Jean-François Barthélémy},\n  title   = {TensND.jl},\n  url     = {https://github.com/jfbarthelemy/TensND.jl},\n  version = {v0.1.0},\n  year    = {2021},\n  month   = {8}\n}","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymPy.jl\nTensors.jl\nOMEinsum.jl\nRotations.jl","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tens3d\nSébastien Brisard's blog","category":"page"}]
}
