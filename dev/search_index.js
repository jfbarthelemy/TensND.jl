var documenterSearchIndex = {"docs":
[{"location":"man/tensors/#Tensors","page":"Tensors","title":"Tensors","text":"A tensor, parametrized by an order and a dimension, is in general defined by\n\nan array or a set of condensed parameters (e.g. isotropic tensors),\na basis,\na set of variances (covariant :cov or contravariant :cont) useful if the basis is not orthonormal.\n\nIn practice, the type of basis conditions the type of tensor (TensCanonical, TensRotated, TensOrthogonal, Tens or even TensISO in case of isotropic tensor).\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0])\nBasis{3, Sym}\nâ†’ basis: 3Ã—3 Matrix{Sym}:\n 0  1  1\n 1  0  1\n 1  1  0\nâ†’ dual basis: 3Ã—3 Matrix{Sym}:\n -1/2   1/2   1/2\n  1/2  -1/2   1/2\n  1/2   1/2  -1/2\nâ†’ covariant metric tensor: 3Ã—3 Symmetric{Sym, Matrix{Sym}}:\n 2  1  1\n 1  2  1\n 1  1  2\nâ†’ contravariant metric tensor: 3Ã—3 Symmetric{Sym, Matrix{Sym}}:\n  3/4  -1/4  -1/4\n -1/4   3/4  -1/4\n -1/4  -1/4   3/4\n\njulia> V = Tens(Tensor{1,3}(i -> symbols(\"v$i\", real = true)))\n(v1)ğÂ¹ + (v2)ğÂ² + (v3)ğÂ³\n\njulia> components(V, â„¬, (:cont,))\n3-element Vector{Sym}:\n -v1/2 + v2/2 + v3/2\n  v1/2 - v2/2 + v3/2\n  v1/2 + v2/2 - v3/2\n\njulia> components(V, â„¬, (:cov,))\n3-element Vector{Sym}:\n vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚\n\njulia> â„¬Ì„ = normalize(â„¬)\nBasis{3, Sym}\nâ†’ basis: 3Ã—3 Matrix{Sym}:\n         0  sqrt(2)/2  sqrt(2)/2\n sqrt(2)/2          0  sqrt(2)/2\n sqrt(2)/2  sqrt(2)/2          0\nâ†’ dual basis: 3Ã—3 Matrix{Sym}:\n -sqrt(2)/2   sqrt(2)/2   sqrt(2)/2\n  sqrt(2)/2  -sqrt(2)/2   sqrt(2)/2\n  sqrt(2)/2   sqrt(2)/2  -sqrt(2)/2\nâ†’ covariant metric tensor: 3Ã—3 Symmetric{Sym, Matrix{Sym}}:\n   1  1/2  1/2\n 1/2    1  1/2\n 1/2  1/2    1\nâ†’ contravariant metric tensor: 3Ã—3 Symmetric{Sym, Matrix{Sym}}:\n  3/2  -1/2  -1/2\n -1/2   3/2  -1/2\n -1/2  -1/2   3/2\n\njulia> components(V, â„¬Ì„, (:cov,))\n3-element Vector{Sym}:\n sqrt(2)*v2/2 + sqrt(2)*v3/2\n sqrt(2)*v1/2 + sqrt(2)*v3/2\n sqrt(2)*v1/2 + sqrt(2)*v2/2\n\njulia> T = Tens(Tensor{2,3}((i, j) -> symbols(\"t$i$j\", real = true)))\n(t11)ğÂ¹âŠ—ğÂ¹ + (t21)ğÂ²âŠ—ğÂ¹ + (t31)ğÂ³âŠ—ğÂ¹ + (t12)ğÂ¹âŠ—ğÂ² + (t22)ğÂ²âŠ—ğÂ² + (t32)ğÂ³âŠ—ğÂ² + (t13)ğÂ¹âŠ—ğÂ³ + (t23)ğÂ²âŠ—ğÂ³ + (t33)ğÂ³âŠ—ğÂ³\n\njulia> components(T, â„¬, (:cov, :cov))\n3Ã—3 Matrix{Sym}:\n tâ‚‚â‚‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚‚â‚‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚‚â‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚‚â‚ + tâ‚‚â‚‚\n\njulia> factor(simplify(components(T, â„¬, (:cont, :cov))))\n3Ã—3 Matrix{Sym}:\n -(t12 + t13 - t22 - t23 - t32 - t33)/2  -(t11 + t13 - t21 - t23 - t31 - t33)/2  -(t11 + t12 - t21 - t22 - t31 - t32)/2\n  (t12 + t13 - t22 - t23 + t32 + t33)/2   (t11 + t13 - t21 - t23 + t31 + t33)/2   (t11 + t12 - t21 - t22 + t31 + t32)/2\n  (t12 + t13 + t22 + t23 - t32 - t33)/2   (t11 + t13 + t21 + t23 - t31 - t33)/2   (t11 + t12 + t21 + t22 - t31 - t32)/2\n\nSpecial tensors are available\n\ntensId2(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: second-order identity (ğŸáµ¢â±¼ = Î´áµ¢â±¼ = 1 if i=j otherwise 0)\ntensId4(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: fourth-order identity with minor symmetries (ğ•€ = ğŸ âŠ Ë¢ ğŸ i.e. (ğ•€)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2)\ntensJ4(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: fourth-order spherical projector (ğ• = (ğŸ âŠ— ğŸ) / dim i.e. (ğ•)áµ¢â±¼â‚–â‚— = Î´áµ¢â±¼Î´â‚–â‚—/dim)\ntensK4(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: fourth-order deviatoric projector (ğ•‚ = ğ•€ - ğ• i.e. (ğ•‚)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2 - Î´áµ¢â±¼Î´â‚–â‚—/dim)\nISO(::Val{dim} = Val(3), ::Val{T} = Val(Sym)) where {dim,T<:Number}: returns ğ•€, ğ•, ğ•‚\n\nThe useful tensor products are the following:\n\nâŠ— tensor product\nâŠ—Ë¢ symmetrized tensor product\nâŠ  modified tensor product\nâŠ Ë¢ symmetrized modified tensor product\nâ‹… contracted product\nâŠ¡ double contracted product\nâŠ™ quadruple contracted product\n\nNOTE: more information about modified tensor products can be found in SÃ©bastien Brisard's blog.\n\njulia> ğŸ = tensId2(3, Sym)\n(1) ğŸ\n\njulia> ğ•€, ğ•, ğ•‚ = ISO(3, Sym) ;\n\njulia> ğ•€ == ğŸ âŠ Ë¢ ğŸ\ntrue\n\njulia> ğ• == (ğŸ âŠ— ğŸ)/3\ntrue\n\njulia> a = Tens(Vec{3}((i,) -> symbols(\"a$i\", real = true))) ;\n\njulia> b = Tens(Vec{3}((i,) -> symbols(\"b$i\", real = true))) ;\n\njulia> a âŠ— b\n(a1*b1)ğÂ¹âŠ—ğÂ¹ + (a2*b1)ğÂ²âŠ—ğÂ¹ + (a3*b1)ğÂ³âŠ—ğÂ¹ + (a1*b2)ğÂ¹âŠ—ğÂ² + (a2*b2)ğÂ²âŠ—ğÂ² + (a3*b2)ğÂ³âŠ—ğÂ² + (a1*b3)ğÂ¹âŠ—ğÂ³ + (a2*b3)ğÂ²âŠ—ğÂ³ + (a3*b3)ğÂ³âŠ—ğÂ³\n\njulia> a âŠ—Ë¢ b\n(a1*b1)ğÂ¹âŠ—ğÂ¹ + (a1*b2/2 + a2*b1/2)ğÂ²âŠ—ğÂ¹ + (a1*b3/2 + a3*b1/2)ğÂ³âŠ—ğÂ¹ + (a1*b2/2 + a2*b1/2)ğÂ¹âŠ—ğÂ² + (a2*b2)ğÂ²âŠ—ğÂ² + (a2*b3/2 + a3*b2/2)ğÂ³âŠ—ğÂ² + (a1*b3/2 + a3*b1/2)ğÂ¹âŠ—ğÂ³\n + (a2*b3/2 + a3*b2/2)ğÂ²âŠ—ğÂ³ + (a3*b3)ğÂ³âŠ—ğÂ³\n\njulia> (Î¸, Ï•, r), (ğá¶¿, ğáµ , ğÊ³), â„¬Ë¢ = init_spherical()\n((Î¸, Ï•, r), (Sym[1, 0, 0], Sym[0, 1, 0], Sym[0, 0, 1]), Sym[cos(Î¸)*cos(Ï•) -sin(Ï•) sin(Î¸)*cos(Ï•); sin(Ï•)*cos(Î¸) cos(Ï•) sin(Î¸)*sin(Ï•); -sin(Î¸) 0 cos(Î¸)])\n\njulia> R = rot3(Î¸, Ï•)\n3Ã—3 RotZYZ{Sym} with indices SOneTo(3)Ã—SOneTo(3)(Ï•, Î¸, 0):\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\n\njulia> A = Tens(R * a)\n(a1*cos(Î¸)*cos(Ï•) - a2*sin(Ï•) + a3*sin(Î¸)*cos(Ï•))ğÂ¹ + (a1*sin(Ï•)*cos(Î¸) + a2*cos(Ï•) + a3*sin(Î¸)*sin(Ï•))ğÂ² + (-a1*sin(Î¸) + a3*cos(Î¸))ğÂ³\n\njulia> simplify(change_tens(A, â„¬Ë¢))\n(a1)ğÂ¹ + (a2)ğÂ² + (a3)ğÂ³","category":"section"},{"location":"man/bases/#Bases","page":"Bases","title":"Bases","text":"An arbitrary basis contains four matrices\n\none in which columns correspond to the covariant vectors of new basis (ğáµ¢) with respect to the canonical one,\none defining the contravariant (or dual) basis (ğâ±),\none defining the metric tensor gáµ¢â±¼=ğáµ¢â‹…ğâ±¼,\none defining the inverse of the  metric tensor gâ±Ê²=ğâ±â‹…ğÊ².\n\nand is built by one the following constructors\n\nBasis(eáµ¢::AbstractMatrix{T},eâ±::AbstractMatrix{T},gáµ¢â±¼::AbstractMatrix{T},gâ±Ê²::AbstractMatrix{T}) where {T}\nBasis(â„¬::AbstractBasis{dim,T}, Ï‡áµ¢::V) where {dim,T,V} where Ï‡áµ¢ is a list of scaling factors applied on the vectors of the basis â„¬\nBasis(v::AbstractMatrix{T}, var::Symbol)\nBasis(Î¸::T1, Ï•::T2, Ïˆ::T3 = 0) where {T1,T2,T3}\nBasis(Î¸::T) where {T}\nBasis{dim,T}() where {dim,T}\n\nDepending on the property of the basis (canonical, orthonormal, orthogonal...), the most relevant type (CanonicalBasis, RotatedBasis, OrthogonalBasis or Basis) is implicitly created by calling Basis.\n\njulia> â„¬ = Basis(Sym[1 0 0; 0 1 0; 0 1 1])\nBasis{3, Sym}\nâ†’ basis: 3Ã—3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  1  1      \nâ†’ dual basis: 3Ã—3 Matrix{Sym}:\n 1  0   0\n 0  1  -1\n 0  0   1\nâ†’ covariant metric tensor: 3Ã—3 Symmetric{Sym, Matrix{Sym}}:\n 1  0  0\n 0  2  1\n 0  1  1\nâ†’ contravariant metric tensor: 3Ã—3 Symmetric{Sym, Matrix{Sym}}:\n 1   0   0\n 0   1  -1\n 0  -1   2\n\njulia> â„¬â‚‚ = Basis(symbols(\"Î¸, Ï•, Ïˆ\", real = true)...)\nRotatedBasis{3, Sym}\nâ†’ basis: 3Ã—3 Matrix{Sym}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\nâ†’ dual basis: 3Ã—3 Matrix{Sym}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\nâ†’ covariant metric tensor: 3Ã—3 TensND.Id2{3, Sym}:\n 1  â‹…  â‹…\n â‹…  1  â‹…\n â‹…  â‹…  1\nâ†’ contravariant metric tensor: 3Ã—3 TensND.Id2{3, Sym}:\n 1  â‹…  â‹…\n â‹…  1  â‹…\n â‹…  â‹…  1\n\nPredefined symbolic or numerical coordinates and basis vectors can be obtained from\n\ninit_cartesian(dim::Integer)\ninit_polar(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true)); canonical = false)\ninit_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true), symbols(\"z\", real = true)); canonical = false)\ninit_spherical(coords = (symbols(\"Î¸\", real = true), symbols(\"Ï•\", real = true), symbols(\"r\", positive = true)); canonical = false)\ninit_rotated(coords = symbols(\"Î¸ Ï• Ïˆ\", real = true); canonical = false)\n\nThe option canonical specifies whether the vector is expressed as a tensor with components in the canonical basis or directly in the rotated basis. The second option (ie canonical = false by default) is often preferable for further calculations in the rotated basis.\n\njulia> (x, y, z), (ğâ‚, ğâ‚‚, ğâ‚ƒ), â„¬ = init_cartesian() ;\n\njulia> (r, Î¸), (ğÊ³, ğá¶¿), â„¬áµ– = init_polar() ;\n\njulia> (r, Î¸, z), (ğÊ³, ğá¶¿, ğá¶»), â„¬á¶œ = init_cylindrical() ;\n\njulia> display(â„¬á¶œ)\nRotatedBasis{3, Sym}\nâ†’ basis: 3Ã—3 Matrix{Sym}:\n cos(Î¸)  -sin(Î¸)  0\n sin(Î¸)   cos(Î¸)  0\n      0        0  1\nâ†’ dual basis: 3Ã—3 Matrix{Sym}:\n cos(Î¸)  -sin(Î¸)  0\n sin(Î¸)   cos(Î¸)  0\n      0        0  1\nâ†’ covariant metric tensor: 3Ã—3 TensND.Id2{3, Sym}:\n 1  â‹…  â‹…\n â‹…  1  â‹…\n â‹…  â‹…  1\nâ†’ contravariant metric tensor: 3Ã—3 TensND.Id2{3, Sym}:\n 1  â‹…  â‹…\n â‹…  1  â‹…\n â‹…  â‹…  1\n\njulia> (Î¸, Ï•, r), (ğá¶¿, ğáµ , ğÊ³), â„¬Ë¢ = init_spherical() ;\n\njulia> components_canon(ğÊ³)\n3-element Vector{Sym}:\n sin(Î¸)â‹…cos(Ï•)\n sin(Î¸)â‹…sin(Ï•)\n        cos(Î¸)\n\njulia> (Î¸, Ï•, Ïˆ), (ğá¶¿, ğáµ , ğÊ³), â„¬Ê³ = init_rotated() ;\n\nNOTE: it is worth noting the unusual order of coordinates and vectors of the spherical basis which have been chosen here so that Î¸ = Ï• = 0 corresponds to the cartesian basis in the correct order.","category":"section"},{"location":"api/#API-of-the-TensND-library","page":"API","title":"API of the TensND library","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#TensND.Basis","page":"API","title":"TensND.Basis","text":"Basis(v::AbstractMatrix{T}, ::Val{:cov})\nBasis{dim, T<:Number}()\nBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\n\nBasis built from a square matrix v where columns correspond either to\n\nprimal vectors ie eáµ¢=v[:,i] if var=:cov as by default\ndual vectors ie eâ±=v[:,i] if var=:cont.\n\nBasis without any argument refers to the canonical basis (CanonicalBasis) in Ráµˆâ±áµ (by default dim=3 and T=Sym)\n\nBasis can also be built from Euler angles (RotatedBasis) Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nThe attributes of this object can be obtained by\n\nvecbasis(â„¬, :cov): square matrix defining the primal basis eáµ¢=e[:,i]\nvecbasis(â„¬, :cont): square matrix defining the dual basis eâ±=E[:,i]\nmetric(â„¬, :cov): square matrix defining the covariant components of the metric tensor gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]\nmetric(â„¬, :cont): square matrix defining the contravariant components of the metric tensor gâ±Ê²=eâ±â‹…eÊ²=gâ±Ê²[i,j]\n\nExamples\n\njulia> v = Sym[1 0 0; 0 1 0; 0 1 1] ; â„¬ = Basis(v)\nBasis{3, Sym}\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# dual basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0   0\n 0  1  -1\n 0  0   1\n# covariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# contravariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1   0   0\n 0   1  -1\n 0  -1   2\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = Basis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.CanonicalBasis","page":"API","title":"TensND.CanonicalBasis","text":"CanonicalBasis{dim, T}\n\nCanonical basis of dimension dim (default: 3) and type T (default: Sym)\n\nThe attributes of this object can be obtained by\n\nvecbasis(â„¬, :cov): square matrix defining the primal basis eáµ¢=e[:,i]=Î´áµ¢â±¼\nvecbasis(â„¬, :cont): square matrix defining the dual basis eâ±=E[:,i]=Î´áµ¢â±¼\nmetric(â„¬, :cov): square matrix defining the covariant components of the metric tensor gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]=Î´áµ¢â±¼\nmetric(â„¬, :cont): square matrix defining the contravariant components of the metric tensor gâ±Ê²=eâ±â‹…eÊ²=gâ±Ê²[i,j]=Î´áµ¢â±¼\n\nExamples\n\njulia> â„¬ = CanonicalBasis()\nCanonicalBasis{3, Sym}\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# dual basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# covariant metric tensor: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# contravariant metric tensor: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> â„¬â‚‚ = CanonicalBasis{2, Float64}()\nCanonicalBasis{2, Float64}\n# basis: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# dual basis: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# covariant metric tensor: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# contravariant metric tensor: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.CoorSystemSym","page":"API","title":"TensND.CoorSystemSym","text":"CoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},bnorm::AbstractBasis{dim,Sym},Ï‡áµ¢::NTuple{dim},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\nCoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\n\nDefine a new coordinate system either from\n\nthe position vector OM, the coordinates coords, the basis of unit vectors (ğáµ¢) bnorm and the LamÃ© coefficients Ï‡áµ¢\nIn this case the natural basis is formed by the vectors ğšáµ¢ = Ï‡áµ¢ ğáµ¢ directly calculated from the input data.\nor the position vector OM and the coordinates coords\nIn this case the natural basis is formed by the vectors ğšáµ¢ = âˆ‚áµ¢OM i.e. by the derivative of the position vector with respect to the iáµ—Ê° coordinate\n\nOptional parameters can be provided:\n\ntmp_coords contains temporary variables depending on coordinates (in order to allow symbolic simplifications)\nparams contains possible parameters involved in OM\nrules contains a Dict with substitution rules to facilitate the simplification of formulas\ntmp_var contains a Dict with substitution of coordinates by temporary variables\nto_coords indicates how to eliminate the temporary variables to come back to the actual coordinates before derivation for Examples\n\nExamples\n\njulia> Ï•, p = symbols(\"Ï• p\", real = true) ;\n\njulia> pÌ„, q, qÌ„, c = symbols(\"pÌ„ q qÌ„ c\", positive = true) ;\n\njulia> coords = (Ï•, p, q) ; tmp_coords = (pÌ„, qÌ„) ; params = (c,) ;\n\njulia> OM = Tens(c * [pÌ„ * qÌ„ * cos(Ï•), pÌ„ * qÌ„ * sin(Ï•), p * q]) ;\n\njulia> Spheroidal = CoorSystemSym(OM, coords, tmp_coords, params; tmp_var = Dict(1-p^2 => pÌ„^2, q^2-1 => qÌ„^2), to_coords = Dict(pÌ„ => âˆš(1-p^2), qÌ„ => âˆš(q^2-1))) ;\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.RotatedBasis","page":"API","title":"TensND.RotatedBasis","text":"RotatedBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\nRotatedBasis(Î¸::T<:Number)\n\nOrthonormal basis of dimension dim (default: 3) and type T (default: Sym) built from Euler angles Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.SubManifoldSym","page":"API","title":"TensND.SubManifoldSym","text":"CoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},bnorm::AbstractBasis{dim,Sym},Ï‡áµ¢::NTuple{dim},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\nCoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\n\nDefine a new coordinate system either from\n\nthe position vector OM, the coordinates coords, the basis of unit vectors (ğáµ¢) bnorm and the LamÃ© coefficients Ï‡áµ¢\nIn this case the natural basis is formed by the vectors ğšáµ¢ = Ï‡áµ¢ ğáµ¢ directly calculated from the input data.\nor the position vector OM and the coordinates coords\nIn this case the natural basis is formed by the vectors ğšáµ¢ = âˆ‚áµ¢OM i.e. by the derivative of the position vector with respect to the iáµ—Ê° coordinate\n\nOptional parameters can be provided:\n\ntmp_coords contains temporary variables depending on coordinates (in order to allow symbolic simplifications)\nparams contains possible parameters involved in OM\nrules contains a Dict with substitution rules to facilitate the simplification of formulas\ntmp_var contains a Dict with substitution of coordinates by temporary variables\nto_coords indicates how to eliminate the temporary variables to come back to the actual coordinates before derivation for Examples\n\nExamples\n\njulia> Ï•, p = symbols(\"Ï• p\", real = true) ;\n\njulia> pÌ„, q, qÌ„, c = symbols(\"pÌ„ q qÌ„ c\", positive = true) ;\n\njulia> coords = (Ï•, p, q) ; tmp_coords = (pÌ„, qÌ„) ; params = (c,) ;\n\njulia> OM = Tens(c * [pÌ„ * qÌ„ * cos(Ï•), pÌ„ * qÌ„ * sin(Ï•), p * q]) ;\n\njulia> Spheroidal = CoorSystemSym(OM, coords, tmp_coords, params; tmp_var = Dict(1-p^2 => pÌ„^2, q^2-1 => qÌ„^2), to_coords = Dict(pÌ„ => âˆš(1-p^2), qÌ„ => âˆš(q^2-1))) ;\n\n\n\n\n\n","category":"type"},{"location":"api/#TensND.Tens","page":"API","title":"TensND.Tens","text":"Tens{order,dim,T,A<:AbstractArray}\n\nTensor type of any order defined by\n\na multidata of components (of any type heriting from AbstractArray, e.g. Tensor or SymmetricTensor)\na basis of AbstractBasis type\na tuple of variances (covariant :cov or contravariant :cont) of length equal to the order of the tensor\n\nExamples\n\njulia> â„¬ = Basis(Sym[1 0 0; 0 1 0; 0 1 1]) ;\n\njulia> T = Tens(metric(â„¬,:cov),â„¬,(:cov,:cov))\nTens{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# var: (:cov, :cov)\n\njulia> components(T,(:cont,:cov),b)\n3Ã—3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"type"},{"location":"api/#LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"LinearAlgebra.dot","text":"dot(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a contracted product between two tensors\n\na â‹… b = aâ±bâ±¼\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.normalize","page":"API","title":"LinearAlgebra.normalize","text":"normalize(â„¬::AbstractBasis, var = cov)\n\nBuild a basis after normalization of column vectors of input matrix v where columns define either\n\nprimal vectors ie eáµ¢=v[:,i]/norm(v[:,i]) if var = :cov as by default\ndual vector ie eâ±=v[:,i]/norm(v[:,i]) if var = :cont.\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.DIV-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Symbolics.Num, Sym}}","page":"API","title":"TensND.DIV","text":"DIV(t::AbstractTens{order,dim,Sym},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the divergence  of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.DIV-Union{Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, Sym}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.DIV","text":"DIV(T::AbstractTens{order,dim,Sym},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the divergence  of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.GRAD-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Symbolics.Num, Sym}}","page":"API","title":"TensND.GRAD","text":"GRAD(t::Union{t,AbstractTens{order,dim,T}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the gradient of t with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.GRAD-Union{Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, Sym}, Sym}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.GRAD","text":"GRAD(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the gradient of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.HESS-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Symbolics.Num, Sym}}","page":"API","title":"TensND.HESS","text":"HESS(t::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the Hessian of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.HESS-Union{Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, Sym}, Sym}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.HESS","text":"HESS(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the Hessian of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.ISO-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.ISO","text":"ISO(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nReturn the three fourth-order isotropic tensors ğ•€, ğ•, ğ•‚\n\nExamples\n\njulia> ğ•€, ğ•, ğ•‚ = ISO() ;\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T}, Tensors.SymmetricTensor{4, dim, T}, Tensors.Tensor{2, dim, T}, Tensors.Tensor{4, dim, T}, Tensors.Tensor{3, dim, T}} where {dim, T}}","page":"API","title":"TensND.KM","text":"KM(t::AbstractTens{order,dim}; kwargs...)\nKM(t::AbstractTens{order,dim}, var::NTuple{order,Symbol}, b::AbstractBasis{dim}; kwargs...)\n\nWrite the components of a second or fourth order tensor in Kelvin-Mandel notation\n\nExamples\n\njulia> Ïƒ = Tens(SymmetricTensor{2,3}((i, j) -> symbols(\"Ïƒ$i$j\", real = true))) ;\n\njulia> KM(Ïƒ)\n6-element Vector{Sym}:\n         Ïƒ11\n         Ïƒ22\n         Ïƒ33\n      âˆš2â‹…Ïƒ32\n      âˆš2â‹…Ïƒ31\n      âˆš2â‹…Ïƒ21\n\njulia> C = Tens(SymmetricTensor{4,3}((i, j, k, l) -> symbols(\"C$i$j$k$l\", real = true))) ;\n\njulia> KM(C)\n6Ã—6 Matrix{Sym}:\n         Câ‚â‚â‚â‚     Câ‚â‚â‚‚â‚‚     Câ‚â‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚â‚â‚ƒâ‚‚  âˆš2â‹…Câ‚â‚â‚ƒâ‚  âˆš2â‹…Câ‚â‚â‚‚â‚\n         Câ‚‚â‚‚â‚â‚     Câ‚‚â‚‚â‚‚â‚‚     Câ‚‚â‚‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚‚  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚  âˆš2â‹…Câ‚‚â‚‚â‚‚â‚\n         Câ‚ƒâ‚ƒâ‚â‚     Câ‚ƒâ‚ƒâ‚‚â‚‚     Câ‚ƒâ‚ƒâ‚ƒâ‚ƒ  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚‚â‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚â‚‚â‚\n      âˆš2â‹…Câ‚‚â‚â‚â‚  âˆš2â‹…Câ‚‚â‚â‚‚â‚‚  âˆš2â‹…Câ‚‚â‚â‚ƒâ‚ƒ   2â‹…Câ‚‚â‚â‚ƒâ‚‚   2â‹…Câ‚‚â‚â‚ƒâ‚   2â‹…Câ‚‚â‚â‚‚â‚\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.KM-Union{Tuple{TensISO{order, dim}}, Tuple{dim}, Tuple{order}} where {order, dim}","page":"API","title":"TensND.KM","text":"KM(v::AllIsotropic{dim}; kwargs...)\n\nKelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.LAPLACE-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Symbolics.Num, Sym}}","page":"API","title":"TensND.LAPLACE","text":"LAPLACE(t::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the Laplace operator of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.LAPLACE-Union{Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, Sym}, Sym}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.LAPLACE","text":"LAPLACE(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the Laplace operator of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.LeviCivita","page":"API","title":"TensND.LeviCivita","text":"LeviCivita(T::Type{<:Number} = Sym)\n\nBuilds an Array{T,3} of Levi-Civita Symbol Ïµáµ¢â±¼â‚– = (i-j) (j-k) (k-i) / 2\n\nExamples\n\njulia> Îµ = LeviCivita(Sym)\n3Ã—3Ã—3 Array{Sym, 3}:\n[:, :, 1] =\n 0   0  0\n 0   0  1\n 0  -1  0\n\n[:, :, 2] =\n 0  0  -1\n 0  0   0\n 1  0   0\n\n[:, :, 3] =\n  0  1  0\n -1  0  0\n  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.SYMGRAD-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, T}, T}, CoorSystemSym{dim, T}}} where {order, dim, T<:Union{Symbolics.Num, Sym}}","page":"API","title":"TensND.SYMGRAD","text":"SYMGRAD(t::Union{T,AbstractTens{order,dim,T}},CS::CoorSystemSym{dim}) where {order,dim,T<:Number}\n\nCalculate the symmetrized gradient of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.SYMGRAD-Union{Tuple{dim}, Tuple{order}, Tuple{Union{AbstractTens{order, dim, Sym}, Sym}, SubManifoldSym{dim}}} where {order, dim}","page":"API","title":"TensND.SYMGRAD","text":"SYMGRAD(T::Union{Sym,AbstractTens{order,dim,Sym}},SM::SubManifoldSym{dim}) where {order,dim}\n\nCalculate the symmetrized gradient of T with respect to the coordinate system SM\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"API","title":"TensND.angles","text":"angles(M::AbstractMatrix{T})\n\nDetermine the Euler angles corresponding to the input matrix supposed to be a rotation matrix or at least a similarity\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\njulia> angles(â„¬Ê³)\n(Î¸ = Î¸, Ï• = Ï•, Ïˆ = Ïˆ)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.change_tens-Tuple{AbstractTens, TensND.AbstractBasis, NTuple{N, T} where {N, T}}","page":"API","title":"TensND.change_tens","text":"change_tens(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim},var::NTuple{order,Symbol})\nchange_tens(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim})\nchange_tens(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nRewrite the same tensor with components corresponding to new variances and/or to a new basis\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, â„¬, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> â„¬â‚€ = Basis(Sym[0 1 1; 1 0 1; 1 1 1]) ;\n\njulia> TV0 = change_tens(TV, â„¬â‚€)\nTens{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n     -vâ‚ + vâ‚ƒ\n     -vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚‚ - vâ‚ƒ\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.change_tens_canon-Tuple{AbstractTens}","page":"API","title":"TensND.change_tens_canon","text":"change_tens_canon(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nRewrite the same tensor with components corresponding to the canonical basis\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)), â„¬)\nTens{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\njulia> TV0 = change_tens_canon(TV)\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n      vâ‚‚ + vâ‚ƒ\n      vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚ + vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.components-Tuple{AbstractTens}","page":"API","title":"TensND.components","text":"components(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim},var::NTuple{order,Symbol})\ncomponents(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim})\ncomponents(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nExtract the components of a tensor for new variances and/or in a new basis\n\nExamples\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, â„¬, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> components(TV, â„¬, (:cov,))\n3-element Vector{Sym}:\n vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚\n\njulia> simplify.(components(TV, normalize(â„¬), (:cov,)))\n3-element Vector{Sym}:\n sqrt(2)*(v2 + v3)/2\n sqrt(2)*(v1 + v3)/2\n sqrt(2)*(v1 + v2)/2\n\njulia> TT = Tens(Tensor{2,3}((i,j)->symbols(\"t$i$j\",real=true)))\nTensND.TensCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3Ã—3 Tensor{2, 3, Sym, 9}:\n tâ‚â‚  tâ‚â‚‚  tâ‚â‚ƒ\n tâ‚‚â‚  tâ‚‚â‚‚  tâ‚‚â‚ƒ\n tâ‚ƒâ‚  tâ‚ƒâ‚‚  tâ‚ƒâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont, :cont)\n\njulia> components(TT, â„¬, (:cov,:cov))\n3Ã—3 Matrix{Sym}:\n tâ‚‚â‚‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚‚â‚‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚‚â‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚‚â‚ + tâ‚‚â‚‚\n\njulia> factor.(components(TT, â„¬, (:cont,:cov)))\n3Ã—3 Matrix{Sym}:\n -(t12 + t13 - t22 - t23 - t32 - t33)/2  â€¦  -(t11 + t12 - t21 - t22 - t31 - t32)/2\n  (t12 + t13 - t22 - t23 + t32 + t33)/2      (t11 + t12 - t21 - t22 + t31 + t32)/2\n  (t12 + t13 + t22 + t23 - t32 - t33)/2      (t11 + t12 + t21 + t22 - t31 - t32)/2\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.components_canon-Tuple{AbstractTens}","page":"API","title":"TensND.components_canon","text":"components_canon(t::AbstractTens)\n\nExtract the components of a tensor in the canonical basis\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.contract-Union{Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim}, Integer, Integer}} where {order, dim}","page":"API","title":"TensND.contract","text":"contract(t::AbstractTens{order,dim}, i::Integer, j::Integer)\n\nCalculate the tensor obtained after contraction with respect to the indices i and j\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_cartesian-Union{Tuple{}, Tuple{NTuple{dim, T}}, Tuple{T}, Tuple{dim}} where {dim, T<:Union{Symbolics.Num, Sym}}","page":"API","title":"TensND.coorsys_cartesian","text":"coorsys_cartesian(coords = symbols(\"x y z\", real = true))\n\nReturn the cartesian coordinate system\n\nExamples\n\njulia> Cartesian = coorsys_cartesian() ; ğ— = getcoords(Cartesian) ; ğ„ = unitvec(Cartesian) ; â„¬ = getbasis(Cartesian)\n\njulia> ğ›” = Tens(SymmetricTensor{2,3}((i, j) -> SymFunction(\"Ïƒ$i$j\", real = true)(ğ—...))) ;\n\njulia> DIV(ğ›”, CScar)\nTens.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n Derivative(Ïƒ11(x, y, z), x) + Derivative(Ïƒ21(x, y, z), y) + Derivative(Ïƒ31(x, y, z), z)\n Derivative(Ïƒ21(x, y, z), x) + Derivative(Ïƒ22(x, y, z), y) + Derivative(Ïƒ32(x, y, z), z)\n Derivative(Ïƒ31(x, y, z), x) + Derivative(Ïƒ32(x, y, z), y) + Derivative(Ïƒ33(x, y, z), z)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_cylindrical-Union{Tuple{}, Tuple{Tuple{T, T, T}}, Tuple{T}} where T<:Union{Symbolics.Num, Sym}","page":"API","title":"TensND.coorsys_cylindrical","text":"coorsys_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true), symbols(\"z\", real = true)); canonical = false)\n\nReturn the cylindrical coordinate system\n\nExamples\n\njulia> Cylindrical = coorsys_cylindrical() ; rÎ¸z = getcoords(Cylindrical) ; ğÊ³, ğá¶¿, ğá¶» = unitvec(Cylindrical) ; â„¬á¶œ = getbasis(Cylindrical)\n\njulia> ğ¯ = Tens(Vec{3}(i -> SymFunction(\"v$(rÎ¸z[i])\", real = true)(rÎ¸z...)), â„¬á¶œ) ;\n\njulia> DIV(ğ¯, Cylindrical)\n                                                  âˆ‚\n                                    vr(r, Î¸, z) + â”€â”€(vÎ¸(r, Î¸, z))\nâˆ‚                 âˆ‚                               âˆ‚Î¸\nâ”€â”€(vr(r, Î¸, z)) + â”€â”€(vz(r, Î¸, z)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâˆ‚r                âˆ‚z                              r\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_polar-Union{Tuple{}, Tuple{Tuple{T, T}}, Tuple{T}} where T<:Union{Symbolics.Num, Sym}","page":"API","title":"TensND.coorsys_polar","text":"coorsys_polar(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true)); canonical = false)\n\nReturn the polar coordinate system\n\nExamples\n\njulia> Polar = coorsys_polar() ; r, Î¸ = getcoords(Polar) ; ğÊ³, ğá¶¿ = unitvec(Polar) ; â„¬áµ– = getbasis(Polar)\n\njulia> f = SymFunction(\"f\", real = true)(r, Î¸) ;\n\njulia> LAPLACE(f, Polar)\n                               2\n                              âˆ‚\n                             â”€â”€â”€(f(r, Î¸))\n                               2\n               âˆ‚             âˆ‚Î¸\n  2            â”€â”€(f(r, Î¸)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n âˆ‚             âˆ‚r                 r\nâ”€â”€â”€(f(r, Î¸)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  2                        r\nâˆ‚r\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_spherical-Union{Tuple{}, Tuple{Tuple{T, T, T}}, Tuple{T}} where T<:Union{Symbolics.Num, Sym}","page":"API","title":"TensND.coorsys_spherical","text":"coorsys_spherical(coords = (symbols(\"Î¸\", real = true), symbols(\"Ï•\", real = true), symbols(\"r\", positive = true)); canonical = false)\n\nReturn the spherical coordinate system\n\nExamples\n\njulia> Spherical = coorsys_spherical() ; Î¸, Ï•, r = getcoords(Spherical) ; ğá¶¿, ğáµ , ğÊ³ = unitvec(Spherical) ; â„¬Ë¢ = getbasis(Spherical)\n\njulia> for Ïƒâ±Ê² âˆˆ (\"ÏƒÊ³Ê³\", \"Ïƒá¶¿á¶¿\", \"Ïƒáµ áµ \") @eval $(Symbol(Ïƒâ±Ê²)) = SymFunction($Ïƒâ±Ê², real = true)($r) end ;\n\njulia> ğ›” = ÏƒÊ³Ê³ * ğÊ³ âŠ— ğÊ³ + Ïƒá¶¿á¶¿ * ğá¶¿ âŠ— ğá¶¿ + Ïƒáµ áµ  * ğáµ  âŠ— ğáµ  ;\n\njulia> divğ›” = DIV(ğ›”, Spherical)\nTens.TensRotated{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n                              (-Ïƒáµ áµ (r) + Ïƒá¶¿á¶¿(r))*cos(Î¸)/(r*sin(Î¸))\n                                                                 0\n Derivative(ÏƒÊ³Ê³(r), r) + (ÏƒÊ³Ê³(r) - Ïƒáµ áµ (r))/r + (ÏƒÊ³Ê³(r) - Ïƒá¶¿á¶¿(r))/r\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\n# var: (:cont,)\n\njulia> divğ›” â‹… ğÊ³\nd            ÏƒÊ³Ê³(r) - Ïƒáµ áµ (r)   ÏƒÊ³Ê³(r) - Ïƒá¶¿á¶¿(r)\nâ”€â”€(ÏƒÊ³Ê³(r)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndr                  r                 r\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.coorsys_spheroidal-Union{Tuple{}, Tuple{Tuple{T, T, T}}, Tuple{T}, Tuple{Tuple{T, T, T}, Any}, Tuple{Tuple{T, T, T}, Any, Any}} where T<:Union{Symbolics.Num, Sym}","page":"API","title":"TensND.coorsys_spheroidal","text":"coorsys_spheroidal(coords = (symbols(\"Ï•\", real = true),symbols(\"p\", real = true),symbols(\"q\", positive = true),),\n                        c = symbols(\"c\", positive = true),tmp_coords = (symbols(\"pÌ„ qÌ„\", positive = true)...,),)\n\nReturn the spheroidal coordinate system\n\nExamples\n\njulia> Spheroidal = coorsys_spheroidal() ; OM = getOM(Spheroidal)\nTens.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n câ‹…pÌ„â‹…qÌ„â‹…cos(Ï•)\n câ‹…pÌ„â‹…qÌ„â‹…sin(Ï•)\n          câ‹…pâ‹…q\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> LAPLACE(OM[1]^2, Spheroidal)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.init_cartesian","page":"API","title":"TensND.init_cartesian","text":"init_cartesian(coords = symbols(\"x y z\", real = true))\n\nReturns the coordinates, unit vectors and basis of the cartesian basis\n\nExamples\n\njulia> coords, vectors, â„¬ = init_cartesian() ; x, y, z = coords ; ğâ‚, ğâ‚‚, ğâ‚ƒ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_cylindrical","page":"API","title":"TensND.init_cylindrical","text":"init_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"Î¸ z\", real = true)...); canonical = false)\n\nReturns the coordinates, base vectors and basis of the cylindrical basis\n\nExamples\n\njulia> coords, vectors, â„¬á¶œ = init_cylindrical() ; r, Î¸, z = coords ; ğÊ³, ğá¶¿, ğá¶» = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_polar","page":"API","title":"TensND.init_polar","text":"init_polar(coords = (symbols(\"r Î¸\", real = true)); canonical = false)\n\nReturns the coordinates, base vectors and basis of the polar basis\n\nExamples\n\njulia> coords, vectors, â„¬áµ– = init_polar() ; r, Î¸ = coords ; ğÊ³, ğá¶¿ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_rotated","page":"API","title":"TensND.init_rotated","text":"init_rotated(coords = symbols(\"Î¸ Ï• Ïˆ\", real = true); canonical = false)\n\nReturn the angles, base vectors and basis of the rotated basis. Note that here the coordinates are angles and do not represent a valid parametrization of â„Â³\n\nExamples\n\njulia> angles, vectors, â„¬Ê³ = init_rotated() ; Î¸, Ï•, Ïˆ = angles ; ğá¶¿, ğáµ , ğÊ³ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.init_spherical","page":"API","title":"TensND.init_spherical","text":"init_spherical(coords = (symbols(\"Î¸ Ï•\", real = true)..., symbols(\"r\", positive = true)); canonical = false)\n\nReturn the coordinates, base vectors and basis of the spherical basis. Take care that the order of the 3 vectors is ğá¶¿, ğáµ , ğÊ³ so that the basis coincides with the canonical one when the angles are null and in consistency the coordinates are ordered as Î¸, Ï•, r.\n\nExamples\n\njulia> coords, vectors, â„¬Ë¢ = init_spherical() ; Î¸, Ï•, r = coords ; ğá¶¿, ğáµ , ğÊ³  = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.invKM-Tuple{Type{<:Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T}, Tensors.SymmetricTensor{4, dim, T}, Tensors.Tensor{2, dim, T}, Tensors.Tensor{4, dim, T}, Tensors.Tensor{3, dim, T}} where {dim, T}}, AbstractVecOrMat}","page":"API","title":"TensND.invKM","text":"invKM(v::AbstractVecOrMat; kwargs...)\n\nDefine a tensor from a Kelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.isorthogonal-Tuple{TensND.AbstractBasis}","page":"API","title":"TensND.isorthogonal","text":"isorthogonal(â„¬::AbstractBasis)\n\nCheck whether the basis â„¬ is orthogonal\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.isorthonormal-Tuple{TensND.AbstractBasis}","page":"API","title":"TensND.isorthonormal","text":"isorthonormal(â„¬::AbstractBasis)\n\nCheck whether the basis â„¬ is orthonormal\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.metric-Tuple{TensND.AbstractBasis, Val{:cov}}","page":"API","title":"TensND.metric","text":"metric(â„¬::AbstractBasis, var = :cov)\n\nReturn the covariant (if var = :cov) or contravariant (if var = :cont) metric matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"TensND.otimesul","text":"otimesul(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a special tensor product between two tensors of at least second order\n\n(ğš âŠ Ë¢ ğ›) âŠ¡ ğ© = (ğš âŠ  ğ›) âŠ¡ (ğ© + áµ—ğ©)/2  = 1/2(aâ±áµbÊ²Ë¡+aâ±Ë¡bÊ²áµ) pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.qcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"TensND.qcontract","text":"qcontract(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a quadruple contracted product between two tensors\n\nğ”¸ âŠ™ ğ”¹ = Aáµ¢â±¼â‚–â‚—Bâ±Ê²áµË¡\n\nExamples\n\njulia> ğ•€ = tğ•€(Sym) ; ğ• = tğ•(Sym) ; ğ•‚ = tğ•‚(Sym) ;\n\njulia> ğ•€ âŠ™ ğ•€\n6\n\njulia> ğ• âŠ™ ğ•€\n1\n\njulia> ğ•‚ âŠ™ ğ•€\n5\n\njulia> ğ•‚ âŠ™ ğ•\n0\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.rot2-Tuple{Any}","page":"API","title":"TensND.rot2","text":"rot2(Î¸)\n\nReturn a 2D rotation matrix with respect to the angle Î¸\n\nExamples\n\njulia> rot2(Î¸)\n2Ã—2 Tensor{2, 2, Sym, 4}:\n cos(Î¸)  -sin(Î¸)\n sin(Î¸)   cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.rot3","page":"API","title":"TensND.rot3","text":"rot3(Î¸, Ï• = 0, Ïˆ = 0)\n\nReturn a rotation matrix with respect to the 3 Euler angles Î¸, Ï•, Ïˆ\n\nExamples\n\njulia> cÎ¸, cÏ•, cÏˆ, sÎ¸, sÏ•, sÏˆ = symbols(\"cÎ¸ cÏ• cÏˆ sÎ¸ sÏ• sÏˆ\", real = true) ;\n\njulia> d = Dict(cos(Î¸) => cÎ¸, cos(Ï•) => cÏ•, cos(Ïˆ) => cÏˆ, sin(Î¸) => sÎ¸, sin(Ï•) => sÏ•, sin(Ïˆ) => sÏˆ) ;\n\njulia> subs.(rot3(Î¸, Ï•, Ïˆ),d...)\n3Ã—3 StaticArrays.SMatrix{3, 3, Sym, 9} with indices SOneTo(3)Ã—SOneTo(3):\n cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•  -cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•  cÏ•â‹…sÎ¸\n cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ  -cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•  sÎ¸â‹…sÏ•\n           -cÏˆâ‹…sÎ¸              sÎ¸â‹…sÏˆ     cÎ¸\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.rot6","page":"API","title":"TensND.rot6","text":"rot6(Î¸, Ï• = 0, Ïˆ = 0)\n\nReturn a rotation matrix with respect to the 3 Euler angles Î¸, Ï•, Ïˆ\n\nExamples\n\njulia> cÎ¸, cÏ•, cÏˆ, sÎ¸, sÏ•, sÏˆ = symbols(\"cÎ¸ cÏ• cÏˆ sÎ¸ sÏ• sÏˆ\", real = true) ;\n\njulia> d = Dict(cos(Î¸) => cÎ¸, cos(Ï•) => cÏ•, cos(Ïˆ) => cÏˆ, sin(Î¸) => sÎ¸, sin(Ï•) => sÏ•, sin(Ïˆ) => sÏˆ) ;\n\njulia> R = Tens(subs.(rot3(Î¸, Ï•, Ïˆ),d...))\nTens.TensCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•  -cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•  cÏ•â‹…sÎ¸\n cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ  -cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•  sÎ¸â‹…sÏ•\n           -cÏˆâ‹…sÎ¸              sÎ¸â‹…sÏˆ     cÎ¸\n# var: (:cont, :cont)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> RR = R âŠ Ë¢ R\nTens.TensCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6Ã—6 Matrix{Sym}:\n                          (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)^2                            (-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)^2           cÏ•^2*sÎ¸^2                      âˆš2â‹…cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)                     âˆš2â‹…cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)\n                          (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)^2                            (-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•)^2           sÎ¸^2*sÏ•^2                      âˆš2â‹…sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)                     âˆš2â‹…sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)\n                                     cÏˆ^2*sÎ¸^2                                        sÎ¸^2*sÏˆ^2                cÎ¸^2                                       âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏˆ                                    -âˆš2â‹…cÎ¸â‹…cÏˆâ‹…sÎ¸                                                              -sqrt(2)*cÏˆ*sÎ¸^2*sÏˆ\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)    âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏ•                    cÎ¸*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + sÎ¸^2*sÏˆ*sÏ•                   cÎ¸*(cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ) - cÏˆ*sÎ¸^2*sÏ•                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)    âˆš2â‹…cÎ¸â‹…cÏ•â‹…sÎ¸                    cÎ¸*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•) + cÏ•*sÎ¸^2*sÏˆ                   cÎ¸*(cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•) - cÏˆ*cÏ•*sÎ¸^2                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)\n âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)  âˆš2â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)  sqrt(2)*cÏ•*sÎ¸^2*sÏ•  cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)  cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ) + sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)  (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 = invKM(subs.(KM(rot6(Î¸, Ï•, Ïˆ)),d...))\nTens.TensCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6Ã—6 Matrix{Sym}:\n                          (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)^2                            (-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)^2           cÏ•^2*sÎ¸^2                      âˆš2â‹…cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)                     âˆš2â‹…cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)\n                          (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)^2                            (-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•)^2           sÎ¸^2*sÏ•^2                      âˆš2â‹…sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)                     âˆš2â‹…sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)\n                                     cÏˆ^2*sÎ¸^2                                        sÎ¸^2*sÏˆ^2                cÎ¸^2                                       âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏˆ                                    -âˆš2â‹…cÎ¸â‹…cÏˆâ‹…sÎ¸                                                              -sqrt(2)*cÏˆ*sÎ¸^2*sÏˆ\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)    âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏ•                    cÎ¸*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + sÎ¸^2*sÏˆ*sÏ•                   cÎ¸*(cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ) - cÏˆ*sÎ¸^2*sÏ•                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)    âˆš2â‹…cÎ¸â‹…cÏ•â‹…sÎ¸                    cÎ¸*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•) + cÏ•*sÎ¸^2*sÏˆ                   cÎ¸*(cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•) - cÏˆ*cÏ•*sÎ¸^2                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)\n âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)  âˆš2â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)  sqrt(2)*cde Liv Lehn Ï•*sÎ¸^2*sÏ•  cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)  cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ) + sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)  (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 == RR\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"TensND.sotimes","text":"sotimes(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a symmetric tensor product between two tensors\n\n(aâ±eáµ¢) âŠ—Ë¢ (bÊ²eâ±¼) = 1/2(aâ±bÊ² + aÊ²bâ±) eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensId2-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensId2","text":"tensId2(::Val{dim}, ::Val{T}) where {dim,T<:Number}\n\nIdentity tensor of second order ğŸáµ¢â±¼ = Î´áµ¢â±¼ = 1 if i=j otherwise 0\n\nExamples\n\njulia> ğŸ = tğŸ() ; KM(ğŸ)\n6-element Vector{Sym}:\n 1\n 1\n 1\n 0\n 0\n 0\n\njulia> ğŸ.data\n3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensId4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensId4","text":"tensId4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nSymmetric identity tensor of fourth order  ğ•€ = ğŸ âŠ Ë¢ ğŸ i.e. (ğ•€)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2\n\nExamples\n\njulia> ğ•€ = tğ•€() ; KM(ğ•€)\n6Ã—6 Matrix{Sym}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  0  1  0  0\n 0  0  0  0  1  0\n 0  0  0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensJ4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensJ4","text":"tensJ4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nSpherical projector of fourth order  ğ• = (ğŸ âŠ— ğŸ) / dim i.e. (ğ•)áµ¢â±¼â‚–â‚— = Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ• = tğ•() ; KM(ğ•)\n6Ã—6 Matrix{Sym}:\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.tensK4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"API","title":"TensND.tensK4","text":"tensK4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nDeviatoric projector of fourth order  ğ•‚ = ğ•€ - ğ• i.e. (ğ•‚)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2 - Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ•‚ = tğ•‚() ; KM(ğ•‚)\n6Ã—6 Matrix{Sym}:\n  2/3  -1/3  -1/3  0  0  0\n -1/3   2/3  -1/3  0  0  0\n -1/3  -1/3   2/3  0  0  0\n    0     0     0  1  0  0\n    0     0     0  0  1  0\n    0     0     0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.vecbasis-Tuple{TensND.AbstractBasis, Val{:cov}}","page":"API","title":"TensND.vecbasis","text":"vecbasis(â„¬::AbstractBasis, var = :cov)\n\nReturn the primal (if var = :cov) or dual (if var = :cont) basis\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.âˆ‚-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, T}, Vararg{Any}}} where {order, dim, T<:Union{Symbolics.Num, Sym}}","page":"API","title":"TensND.âˆ‚","text":"âˆ‚(t::AbstractTens{order,dim,T,A},xáµ¢::T)\n\nReturn the derivative of the tensor t with respect to the variable x_i\n\nExamples\n\n\njulia> (Î¸, Ï•, r), (ğá¶¿, ğáµ , ğÊ³), â„¬Ë¢ = init_spherical() ;\n\njulia> âˆ‚(ğÊ³, Ï•) == sin(Î¸) * ğáµ \ntrue\n\njulia> âˆ‚(ğÊ³ âŠ— ğÊ³,Î¸)\nTens.TensRotated{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 0  0  1\n 0  0  0\n 1  0  0\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\n# var: (:cont, :cont)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.ğ-Union{Tuple{Val{i}}, Tuple{T}, Tuple{dim}, Tuple{i}, Tuple{Val{i}, Val{dim}}, Tuple{Val{i}, Val{dim}, Val{T}}} where {i, dim, T<:Number}","page":"API","title":"TensND.ğ","text":"ğ(i::Integer, dim::Int = 3, T::Type{<:Number} = Sym)\n\nVector of the canonical basis\n\nExamples\n\njulia> ğ(1)\nTens{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.ğË¢-Union{Tuple{Val{1}}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Val{1}, T1}, Tuple{Val{1}, T1, T2}, Tuple{Val{1}, T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"API","title":"TensND.ğË¢","text":"ğË¢(i::Integer, Î¸::T = zero(Sym), Ï•::T = zero(Sym), Ïˆ::T = zero(Sym); canonical = false)\n\nVector of the basis rotated with the 3 Euler angles Î¸, Ï•, Ïˆ (spherical if Ïˆ=0)\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ;\n\nTens{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.ğáµ–-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"API","title":"TensND.ğáµ–","text":"ğáµ–(i::Integer, Î¸::T = zero(Sym); canonical = false)\n\nVector of the polar basis\n\nExamples\n\njulia> Î¸ = symbols(\"Î¸\", real = true) ;\n\njulia> ğáµ–(1, Î¸)\nTens{1, 2, Sym, Sym, Vec{2, Sym}, RotatedBasis{2, Sym}}\n# data: 2-element Vec{2, Sym}:\n 1\n 0\n# var: (:cont,)\n# basis: 2Ã—2 Tensor{2, 2, Sym, 4}:\n cos(Î¸)  -sin(Î¸)\n sin(Î¸)   cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.ğá¶œ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"API","title":"TensND.ğá¶œ","text":"ğá¶œ(i::Integer, Î¸::T = zero(Sym); canonical = false)\n\nVector of the cylindrical basis\n\nExamples\n\njulia> Î¸ = symbols(\"Î¸\", real = true) ;\n\njulia> ğá¶œ(1, Î¸)\nTens{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)  -sin(Î¸)  0\n sin(Î¸)   cos(Î¸)  0\n      0        0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"Tensors.dcontract","text":"dcontract(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a double contracted product between two tensors\n\nğ›” âŠ¡ ğ›† = Ïƒâ±Ê²Îµáµ¢â±¼ ğ›” = â„‚ âŠ¡ ğ›†\n\nExamples\n\njulia> ğ›† = Tens(SymmetricTensor{2,3}((i, j) -> symbols(\"Îµ$i$j\", real = true))) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> ğ›” = â„‚ âŠ¡ ğ›†\nTens{2, 3, Sym, Sym, SymmetricTensor{2, 3, Sym, 6}, CanonicalBasis{3, Sym}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n Îµ11*(k + 4*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ21â‹…Î¼                                              2â‹…Îµ31â‹…Î¼\n                                             2â‹…Îµ21â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k + 4*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ32â‹…Î¼\n                                             2â‹…Îµ31â‹…Î¼                                              2â‹…Îµ32â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k + 4*Î¼/3)\n# var: (:cont, :cont)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{orderS, dim}, AbstractTens{order2, dim}}} where {order1, orderS, order2, dim}","page":"API","title":"Tensors.dotdot","text":"dotdot(v1::AbstractTens{order1,dim}, S::AbstractTens{orderS,dim}, v2::AbstractTens{order2,dim})\n\nDefine a bilinear operator ğ¯â‚â‹…ğ•Šâ‹…ğ¯â‚‚\n\nExamples\n\njulia> n = Tens(Sym[0, 0, 1]) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> dotdot(n,â„‚,n) # Acoustic tensor\n3Ã—3 Tens{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}:\n Î¼  0          0\n 0  Î¼          0\n 0  0  k + 4*Î¼/3\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"Tensors.otimes","text":"otimes(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a tensor product between two tensors\n\n(aâ±eáµ¢) âŠ— (bÊ²eâ±¼) = aâ±bÊ² eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"api/#Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim}, AbstractTens{order2, dim}}} where {order1, order2, dim}","page":"API","title":"Tensors.otimesu","text":"otimesu(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefine a special tensor product between two tensors of at least second order\n\n(ğš âŠ  ğ›) âŠ¡ ğ© = ğšâ‹…ğ©â‹…ğ› = aâ±áµbÊ²Ë¡pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"api/#TensND.@set_coorsys","page":"API","title":"TensND.@set_coorsys","text":"@set_coorsys CS\n@set_coorsys(CS)\n\nSet a coordinate system in order to avoid precising it in differential operators\n\nExamples\n\njulia> Spherical = coorsys_spherical() ; Î¸, Ï•, r = getcoords(Spherical) ; ğá¶¿, ğáµ , ğÊ³ = unitvec(Spherical) ; vec = (\"ğá¶¿\", \"ğáµ \", \"ğÊ³\") ;\n\njulia> @set_coorsys Spherical\n\njulia> intrinsic(GRAD(ğÊ³),vec)\n(1/r)ğá¶¿âŠ—ğá¶¿ + (1/r)ğáµ âŠ—ğáµ \n\njulia> intrinsic(DIV(ğÊ³ âŠ— ğÊ³),vec)\n(2/r)ğÊ³\n\njulia> LAPLACE(1/r)\n0\n\n\n\n\n\n","category":"macro"},{"location":"tuto/nlayersphere/#N-layer-sphere","page":"N-layer sphere","title":"N-layer sphere","text":"using TensND, LinearAlgebra, SymPy, Tensors, OMEinsum, Rotations\n\nSpherical = coorsys_spherical()\nÎ¸, Ï•, r = getcoords(Spherical)\nğá¶¿, ğáµ , ğÊ³ = unitvec(Spherical)\nâ„¬Ë¢ = normalized_basis(Spherical)\nğ± = getOM(Spherical)\nğâ‚, ğâ‚‚, ğâ‚ƒ = unitvec(coorsys_cartesian())\nğ•€, ğ•, ğ•‚ = ISO(Val(3),Val(Sym))\nğŸ = tensId2(Val(3),Val(Sym))\nk, Î¼ = symbols(\"k Î¼\", positive = true)\nÎ» = k -2Î¼/3\n\nu = SymFunction(\"u\", real = true)\nğ®Ë¢áµ–Ê° = u(r) * ğÊ³\nğ›†Ë¢áµ–Ê° = SYMGRAD(ğ®Ë¢áµ–Ê°, Spherical)\nğ›”Ë¢áµ–Ê° = Î» * tr(ğ›†Ë¢áµ–Ê°) * ğŸ + 2Î¼ * ğ›†Ë¢áµ–Ê°\nğ“Ë¢áµ–Ê° = ğ›”Ë¢áµ–Ê° â‹… ğÊ³\ndivğ›”Ë¢áµ–Ê° = DIV(ğ›”Ë¢áµ–Ê°, Spherical) ;\neqË¢áµ–Ê° = factor(simplify(divğ›”Ë¢áµ–Ê° â‹… ğÊ³))\nsolË¢áµ–Ê° = dsolve(eqË¢áµ–Ê°, u(r))\nuÌ‚Ë¢áµ–Ê° = solË¢áµ–Ê°.rhs()\nTÌ‚Ë¢áµ–Ê° = factor(simplify(subs(ğ“Ë¢áµ–Ê° â‹… ğÊ³, u(r) => uÌ‚Ë¢áµ–Ê°)))\n\nğ„ = ğŸ - 3ğâ‚ƒâŠ—ğâ‚ƒ\nfá¶¿ = simplify(ğá¶¿ â‹… ğ„ â‹… ğÊ³)\nfÊ³ = simplify(ğÊ³ â‹… ğ„ â‹… ğÊ³)\nuá¶¿ = SymFunction(\"uá¶¿\", real = true)\nuÊ³ = SymFunction(\"uÊ³\", real = true)\nğ®áµˆáµ‰áµ› = uá¶¿(r) * fá¶¿ * ğá¶¿ + uÊ³(r) * fÊ³ * ğÊ³\nğ›†áµˆáµ‰áµ› = SYMGRAD(ğ®áµˆáµ‰áµ›, Spherical)\nğ›”áµˆáµ‰áµ› = Î» * tr(ğ›†áµˆáµ‰áµ›) * ğŸ + 2Î¼ * ğ›†áµˆáµ‰áµ›\nğ“áµˆáµ‰áµ› = ğ›”áµˆáµ‰áµ› â‹… ğÊ³\ndivğ›”áµˆáµ‰áµ› = simplify(DIV(ğ›”áµˆáµ‰áµ›, Spherical))\neqá¶¿áµˆáµ‰áµ› = factor(simplify(divğ›”áµˆáµ‰áµ› â‹… ğá¶¿ / fá¶¿))\neqÊ³áµˆáµ‰áµ› = factor(simplify(divğ›”áµˆáµ‰áµ› â‹… ğÊ³ / fÊ³))\nÎ±, Î› = symbols(\"Î± Î›\", real = true)\neqáµˆáµ‰áµ› = factor.(simplify.(subs.([eqá¶¿áµˆáµ‰áµ›,eqÊ³áµˆáµ‰áµ›], uá¶¿(r) => r^Î±, uÊ³(r) => Î›*r^Î±)))\nÎ±Î› = solve([eq.doit() for eq âˆˆ eqáµˆáµ‰áµ›], [Î±, Î›])\nuÌ‚á¶¿áµˆáµ‰áµ› = sum([Sym(\"C$(i+2)\") * r^Î±Î›[i][1] for i âˆˆ 1:length(Î±Î›)])\nuÌ‚Ê³áµˆáµ‰áµ› = sum([Sym(\"C$(i+2)\") * Î±Î›[i][2] * r^Î±Î›[i][1] for i âˆˆ 1:length(Î±Î›)])\nTÌ‚á¶¿áµˆáµ‰áµ› = factor(simplify(subs(simplify(ğ“áµˆáµ‰áµ› â‹… ğá¶¿ / fá¶¿), uá¶¿(r) => uÌ‚á¶¿áµˆáµ‰áµ›, uÊ³(r) => uÌ‚Ê³áµˆáµ‰áµ›)))\nTÌ‚Ê³áµˆáµ‰áµ› = factor(simplify(subs(simplify(ğ“áµˆáµ‰áµ› â‹… ğÊ³ / fÊ³), uá¶¿(r) => uÌ‚á¶¿áµˆáµ‰áµ›, uÊ³(r) => uÌ‚Ê³áµˆáµ‰áµ›)))","category":"section"},{"location":"man/coorsystems/#Coordinate-systems-and-differential-operators","page":"Coordinate systems and differential operators","title":"Coordinate systems and differential operators","text":"For the moment only symbolic coordinate systems are available. Their numerical counterpart will be later developed. \n\njulia> Polar = coorsys_polar() ; r, Î¸ = getcoords(Polar) ; ğÊ³, ğá¶¿ = unitvec(Polar) ;\n\njulia> @set_coorsys Polar\n\njulia> LAPLACE(SymFunction(\"f\", real = true)(r, Î¸))\n                               2\n                              âˆ‚\n               âˆ‚             â”€â”€â”€(f(r, Î¸))\n  2            â”€â”€(f(r, Î¸))     2\n âˆ‚             âˆ‚r            âˆ‚Î¸\nâ”€â”€â”€(f(r, Î¸)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  2                 r              2\nâˆ‚r                                r\n\njulia> n = symbols(\"n\", integer = true)\nn\n\njulia> simplify(HESS(r^n))\n(n*r^(n - 2)*(n - 1))ğÊ³âŠ—ğÊ³ + (n*r^(n - 2))ğá¶¿âŠ—ğá¶¿\n\njulia> Spherical = coorsys_spherical() ; Î¸, Ï•, r = getcoords(Spherical) ; ğá¶¿, ğáµ , ğÊ³ = unitvec(Spherical) ;\n\njulia> @set_coorsys Spherical\n\njulia> getChristoffel(Spherical)\n3Ã—3Ã—3 Array{Sym, 3}:\n[:, :, 1] =\n   0               0  1/r\n   0  -sin(Î¸)â‹…cos(Î¸)    0\n 1/r               0    0\n\n[:, :, 2] =\n             0  cos(Î¸)/sin(Î¸)    0\n cos(Î¸)/sin(Î¸)              0  1/r\n             0            1/r    0\n\n[:, :, 3] =\n -r            0  0\n  0  -r*sin(Î¸)^2  0\n  0            0  0\n\njulia> â„¬Ë¢ = normalized_basis(Spherical)\nRotatedBasis{3, Sym}\nâ†’ basis: 3Ã—3 Matrix{Sym}:\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\nâ†’ dual basis: 3Ã—3 Matrix{Sym}:\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\nâ†’ covariant metric tensor: 3Ã—3 TensND.Id2{3, Sym}:\n 1  â‹…  â‹…\n â‹…  1  â‹…\n â‹…  â‹…  1\nâ†’ contravariant metric tensor: 3Ã—3 TensND.Id2{3, Sym}:\n 1  â‹…  â‹…\n â‹…  1  â‹…\n â‹…  â‹…  1\n\njulia> for Ïƒâ±Ê² âˆˆ (\"ÏƒÊ³Ê³\", \"Ïƒá¶¿á¶¿\", \"Ïƒáµ áµ \") @eval $(Symbol(Ïƒâ±Ê²)) = SymFunction($Ïƒâ±Ê², real = true)($r) end\n\njulia> ğ›” = ÏƒÊ³Ê³ * ğÊ³ âŠ— ğÊ³ + Ïƒá¶¿á¶¿ * ğá¶¿ âŠ— ğá¶¿ + Ïƒáµ áµ  * ğáµ  âŠ— ğáµ \n(Ïƒá¶¿á¶¿(r))ğá¶¿âŠ—ğá¶¿ + (Ïƒáµ áµ (r))ğáµ âŠ—ğáµ  + (ÏƒÊ³Ê³(r))ğÊ³âŠ—ğÊ³\n\njulia> divğ›” = simplify(DIV(ğ›”))\n((-Ïƒáµ áµ (r) + Ïƒá¶¿á¶¿(r))/(r*tan(Î¸)))ğá¶¿ + ((r*Derivative(ÏƒÊ³Ê³(r), r) + 2*ÏƒÊ³Ê³(r) - Ïƒáµ áµ (r) - Ïƒá¶¿á¶¿(r))/r)ğÊ³","category":"section"},{"location":"man/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/#Brief-description-of-the-package","page":"Getting started","title":"Brief description of the package","text":"The package relies on the definition of\n\nbases which can be of the following types (T denotes the scalar type, subtype of Number)\nCanonicalBasis{dim,T}: fundamental canonical basis in â„áµˆâ±áµ in which the metric tensor is the second-order identity\nRotatedBasis{dim,T}: orthonormal basis in â„áµˆâ±áµ obtained by rotation of the canonical basis by means of one angle if dim=2 or three Euler angles if dim=3, the metric tensor is again the second-order identity\nOrthogonalBasis{dim,T}: orthogonal basis in â„áµˆâ±áµ obtained from a given orthonormal rotated basis by applying a scaling factor along each unit vector, the metric tensor is then diagonal\nBasis{dim,T}: arbitrary basis not entering the previous cases\ntensors\na tensor is determined by a set of data (array or synthetic parameters) corresponding to its order, a basis and a tuple of variances\ndepending on the type of basis, the type of tensor can be TensCanonical{order,dim,T,A}, TensRotated{order,dim,T,A}, TensOrthogonal{order,dim,T,A} or Tens{order,dim,T,A} if the data are stored under the form of an array or a Tensor object (see Tensors.jl), or the type can be TensISO{order,dim,T,N} if the tensor is isotropic and data are stored under the form of a set of parameters (one for order 2 and two for order 4).\nNOTE:     More material symmetry types such as transverse isotropy or orthotropy will be added in the future.\ncoordinate systems\na coordinate system contains all information required to perform differential operations on tensor fields: position vector OM expressed in the canonical basis, coordinate names xâ±, natural basis aáµ¢=âˆ‚áµ¢OM, normalized basis eáµ¢=aáµ¢/||aáµ¢||, Christoffel coefficients Î“áµ¢â±¼áµ=âˆ‚áµ¢aâ±¼â‹…aáµ where (aâ±)(1â‰¤iâ‰¤dim) form the dual basis associated to the natural one\npredefined coordinate systems are available: cartesian, polar, cylindrical, spherical and spheroidal but the user can define new systems\nNOTE:     Note that for the moment the coordinate systems and differential operators have been implemented only for symbolic calculations (using SymPy.jl). Numerical coordinate systems and differential operators based on automatic differentiation will be implemented in the future.","category":"section"},{"location":"man/getting_started/#Detailed-manual","page":"Getting started","title":"Detailed manual","text":"Before detailing explanations about the main features of TensND, it is worth recalling that the use of the libraries TensND and SymPy requires starting scripts by\n\njulia> using TensND, SymPy\n\nThe detailed manual is decomposed into the following chapters\n\nPages = [\n    \"bases.md\",\n    \"tensors.md\",\n    \"coorsystems.md\",\n]\nDepth = 1","category":"section"},{"location":"#Documentation-for-[TensND](https://github.com/jfbarthelemy/TensND.jl)","page":"Home","title":"Documentation for TensND","text":"Package allowing tensor calculations in arbitrary coordinate systems.","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"This Julia package provides tools to perform tensor calculations of any order and any dimension in arbitrary coordinate systems (cartesian, polar, cylindrical, spherical, spheroidal or any user defined coordinate systems...). In particular differential operators are available: gradient, symmetrized gradient, divergence, Laplace, Hessian. The implementation of this library is much inspired by the Maple library Tens3d developed by Jean Garrigues.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:\n\npkg> add TensND\n\nOr, equivalently, via the Pkg API:\n\njulia> import Pkg; Pkg.add(\"TensND\")","category":"section"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"Pages = [\n    \"man/getting_started.md\",\n    \"man/bases.md\",\n    \"man/tensors.md\",\n    \"man/coorsystems.md\",\n]\nDepth = 1","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"Pages = [\n    \"tuto/nlayersphere.md\",\n]\nDepth = 1","category":"section"},{"location":"#Citing-TensND.jl","page":"Home","title":"Citing TensND.jl","text":"@misc{TensND.jl,\n  author  = {Jean-FranÃ§ois BarthÃ©lÃ©my},\n  title   = {TensND.jl},\n  url     = {https://github.com/jfbarthelemy/TensND.jl},\n  version = {v0.1.1},\n  year    = {2021},\n  month   = {8}\n}","category":"section"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"SymPy.jl\nTensors.jl\nOMEinsum.jl\nRotations.jl","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Tens3d\nSÃ©bastien Brisard's blog","category":"section"}]
}
