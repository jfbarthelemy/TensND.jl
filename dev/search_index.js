var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensND","category":"page"},{"location":"#TensND","page":"Home","title":"TensND","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TensND.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TensND]","category":"page"},{"location":"#TensND.Basis","page":"Home","title":"TensND.Basis","text":"Basis(v::AbstractArray{T,2}, ::Val{:cov})\nBasis{dim, T<:Number}()\nBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\n\nBasis built from a square matrix v where columns correspond either to\n\nprimal vectors ie eáµ¢=v[:,i] if var=:cov as by default\ndual vectors ie eâ±=v[:,i] if var=:cont.\n\nBasis without any argument refers to the canonical basis (CanonicalBasis) in Ráµˆâ±áµ (by default dim=3 and T=Sym)\n\nBasis can also be built from Euler angles (RotatedBasis) Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nThe attributes of this object can be obtained by\n\nvecbasis(â„¬, :cov): square matrix defining the primal basis eáµ¢=e[:,i]\nvecbasis(â„¬, :cont): square matrix defining the dual basis eâ±=E[:,i]\nmetric(â„¬, :cov): square matrix defining the covariant components of the metric tensor gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]\nmetric(â„¬, :cont): square matrix defining the contravariant components of the metric tensor gâ±Ê²=eâ±â‹…eÊ²=G[i,j]\n\nExamples\n\njulia> v = Sym[1 0 0; 0 1 0; 0 1 1] ; â„¬ = Basis(v)\nBasis{3, Sym}\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# dual basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0   0\n 0  1  -1\n 0  0   1\n# covariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# contravariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1   0   0\n 0   1  -1\n 0  -1   2\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = Basis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"#TensND.CanonicalBasis","page":"Home","title":"TensND.CanonicalBasis","text":"CanonicalBasis{dim, T}\n\nCanonical basis of dimension dim (default: 3) and type T (default: Sym)\n\nThe attributes of this object can be obtained by\n\nvecbasis(â„¬, :cov): square matrix defining the primal basis eáµ¢=e[:,i]=Î´áµ¢â±¼\nvecbasis(â„¬, :cont): square matrix defining the dual basis eâ±=E[:,i]=Î´áµ¢â±¼\nmetric(â„¬, :cov): square matrix defining the covariant components of the metric tensor gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]=Î´áµ¢â±¼\nmetric(â„¬, :cont): square matrix defining the contravariant components of the metric tensor gâ±Ê²=eâ±â‹…eÊ²=G[i,j]=Î´áµ¢â±¼\n\nExamples\n\njulia> â„¬ = CanonicalBasis()\nCanonicalBasis{3, Sym}\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# dual basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# covariant metric tensor: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# contravariant metric tensor: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> â„¬â‚‚ = CanonicalBasis{2, Float64}()\nCanonicalBasis{2, Float64}\n# basis: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# dual basis: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# covariant metric tensor: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# contravariant metric tensor: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"#TensND.RotatedBasis","page":"Home","title":"TensND.RotatedBasis","text":"RotatedBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\nRotatedBasis(Î¸::T<:Number)\n\nOrthonormal basis of dimension dim (default: 3) and type T (default: Sym) built from Euler angles Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"#TensND.Tensnd","page":"Home","title":"TensND.Tensnd","text":"Tensnd{order,dim,T,A<:AbstractArray,B<:AbstractBasis}\n\nTensor type of any order defined by\n\na multiarray of components (of any type heriting from AbstractArray, e.g. Tensor or SymmetricTensor)\na basis of AbstractBasis type\na tuple of variances (covariant :cov or contravariant :cont) of length equal to the order of the tensor\n\nExamples\n\njulia> â„¬ = Basis(Sym[1 0 0; 0 1 0; 0 1 1]) ;\n\njulia> T = Tensnd(metric(â„¬,:cov),â„¬,(:cov,:cov))\nTensnd{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# var: (:cov, :cov)\n\njulia> components(T,(:cont,:cov),b)\n3Ã—3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"type"},{"location":"#LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T<:Number, A<:AbstractArray}}} where {order1, order2, dim}","page":"Home","title":"LinearAlgebra.dot","text":"dot(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a contracted product between two tensors\n\na â‹… b = aâ±bâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize","page":"Home","title":"LinearAlgebra.normalize","text":"normalize(â„¬::AbstractBasis, var = cov)\n\nBuilds a basis after normalization of column vectors of input matrix v where columns define either\n\nprimal vectors ie eáµ¢=v[:,i]/norm(v[:,i]) if var = :cov as by default\ndual vector ie eâ±=v[:,i]/norm(v[:,i]) if var = :cont.\n\n\n\n\n\n","category":"function"},{"location":"#TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}}","page":"Home","title":"TensND.KM","text":"KM(t::AbstractTensnd{order,dim}; kwargs...)\nKM(t::AbstractTensnd{order,dim}, var::NTuple{order,Symbol}, b::AbstractBasis{dim}; kwargs...)\n\nWrites the components of a second or fourth order tensor in Kelvin-Mandel notation\n\nExamples\n\njulia> Ïƒ = Tensnd(SymmetricTensor{2,3}((i, j) -> symbols(\"Ïƒ$i$j\", real = true))) ;\n\njulia> KM(Ïƒ)\n6-element Vector{Sym}:\n         Ïƒ11\n         Ïƒ22\n         Ïƒ33\n      âˆš2â‹…Ïƒ32\n      âˆš2â‹…Ïƒ31\n      âˆš2â‹…Ïƒ21\n\njulia> C = Tensnd(SymmetricTensor{4,3}((i, j, k, l) -> symbols(\"C$i$j$k$l\", real = true))) ;\n\njulia> KM(C)\n6Ã—6 Matrix{Sym}:\n         Câ‚â‚â‚â‚     Câ‚â‚â‚‚â‚‚     Câ‚â‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚â‚â‚ƒâ‚‚  âˆš2â‹…Câ‚â‚â‚ƒâ‚  âˆš2â‹…Câ‚â‚â‚‚â‚\n         Câ‚‚â‚‚â‚â‚     Câ‚‚â‚‚â‚‚â‚‚     Câ‚‚â‚‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚‚  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚  âˆš2â‹…Câ‚‚â‚‚â‚‚â‚\n         Câ‚ƒâ‚ƒâ‚â‚     Câ‚ƒâ‚ƒâ‚‚â‚‚     Câ‚ƒâ‚ƒâ‚ƒâ‚ƒ  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚‚â‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚â‚‚â‚\n      âˆš2â‹…Câ‚‚â‚â‚â‚  âˆš2â‹…Câ‚‚â‚â‚‚â‚‚  âˆš2â‹…Câ‚‚â‚â‚ƒâ‚ƒ   2â‹…Câ‚‚â‚â‚ƒâ‚‚   2â‹…Câ‚‚â‚â‚ƒâ‚   2â‹…Câ‚‚â‚â‚‚â‚\n\n\n\n\n\n","category":"method"},{"location":"#TensND.LeviCivita","page":"Home","title":"TensND.LeviCivita","text":"LeviCivita(T::Type{<:Number} = Sym)\n\nBuilds an Array{T,3} of Levi-Civita Symbol Ïµáµ¢â±¼â‚– = (i-j) (j-k) (k-i) / 2\n\nExamples\n\njulia> Îµ = LeviCivita(Sym)\n3Ã—3Ã—3 Array{Sym, 3}:\n[:, :, 1] =\n 0   0  0\n 0   0  1\n 0  -1  0\n\n[:, :, 2] =\n 0  0  -1\n 0  0   0\n 1  0   0\n\n[:, :, 3] =\n  0  1  0\n -1  0  0\n  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"#TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"TensND.angles","text":"angles(M::AbstractArray{T,2})\n\nDetermines the Euler angles corresponding to the input matrix supposed to be a rotation matrix or at least a similarity\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\njulia> angles(â„¬Ê³)\n(Î¸ = Î¸, Ï• = Ï•, Ïˆ = Ïˆ)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.change_tens-Tuple{TensND.AbstractTensnd, AbstractBasis, Tuple{Vararg{T, N}} where {N, T}}","page":"Home","title":"TensND.change_tens","text":"change_tens(t::AbstractTensnd{order,dim,T},â„¬::AbstractBasis{dim},var::NTuple{order,Symbol})\nchange_tens(t::AbstractTensnd{order,dim,T},â„¬::AbstractBasis{dim})\nchange_tens(t::AbstractTensnd{order,dim,T},var::NTuple{order,Symbol})\n\nRewrites the same tensor with components corresponding to new variances and/or to a new basis\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tensnd(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensndCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, â„¬, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> â„¬â‚€ = Basis(Sym[0 1 1; 1 0 1; 1 1 1]) ;\n\njulia> TV0 = change_tens(TV, â„¬â‚€)\nTensnd{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n     -vâ‚ + vâ‚ƒ\n     -vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚‚ - vâ‚ƒ\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.change_tens_canon-Tuple{TensND.AbstractTensnd}","page":"Home","title":"TensND.change_tens_canon","text":"change_tens_canon(t::AbstractTensnd{order,dim,T},var::NTuple{order,Symbol})\n\nRewrites the same tensor with components corresponding to the canonical basis\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tensnd(Tensor{1,3}(i->symbols(\"v$i\",real=true)), â„¬)\nTensnd{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\njulia> TV0 = change_tens_canon(TV)\nTensND.TensndCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n      vâ‚‚ + vâ‚ƒ\n      vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚ + vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.components-Tuple{TensND.AbstractTensnd}","page":"Home","title":"TensND.components","text":"components(t::AbstractTensnd{order,dim,T},â„¬::AbstractBasis{dim},var::NTuple{order,Symbol})\ncomponents(t::AbstractTensnd{order,dim,T},â„¬::AbstractBasis{dim})\ncomponents(t::AbstractTensnd{order,dim,T},var::NTuple{order,Symbol})\n\nExtracts the components of a tensor for new variances and/or in a new basis\n\nExamples\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tensnd(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensndCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, â„¬, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> components(TV, â„¬, (:cov,))\n3-element Vector{Sym}:\n vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚\n\njulia> simplify.(components(TV, normalize(â„¬), (:cov,)))\n3-element Vector{Sym}:\n sqrt(2)*(v2 + v3)/2\n sqrt(2)*(v1 + v3)/2\n sqrt(2)*(v1 + v2)/2\n\njulia> TT = Tensnd(Tensor{2,3}((i,j)->symbols(\"t$i$j\",real=true)))\nTensND.TensndCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3Ã—3 Tensor{2, 3, Sym, 9}:\n tâ‚â‚  tâ‚â‚‚  tâ‚â‚ƒ\n tâ‚‚â‚  tâ‚‚â‚‚  tâ‚‚â‚ƒ\n tâ‚ƒâ‚  tâ‚ƒâ‚‚  tâ‚ƒâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont, :cont)\n\njulia> components(TT, â„¬, (:cov,:cov))\n3Ã—3 Matrix{Sym}:\n tâ‚‚â‚‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚‚â‚‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚‚â‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚‚â‚ + tâ‚‚â‚‚\n\njulia> factor.(components(TT, â„¬, (:cont,:cov)))\n3Ã—3 Matrix{Sym}:\n -(t12 + t13 - t22 - t23 - t32 - t33)/2  â€¦  -(t11 + t12 - t21 - t22 - t31 - t32)/2\n  (t12 + t13 - t22 - t23 + t32 + t33)/2      (t11 + t12 - t21 - t22 + t31 + t32)/2\n  (t12 + t13 + t22 + t23 - t32 - t33)/2      (t11 + t12 + t21 + t22 - t31 - t32)/2\n\n\n\n\n\n","category":"method"},{"location":"#TensND.components_canon-Tuple{TensND.AbstractTensnd}","page":"Home","title":"TensND.components_canon","text":"components_canon(t::AbstractTensnd)\n\nExtracts the components of a tensor in the canonical basis\n\n\n\n\n\n","category":"method"},{"location":"#TensND.init_canonical","page":"Home","title":"TensND.init_canonical","text":"init_canonical(T::Type{<:Number} = Sym)\n\nReturns the canonical basis and the 3 unit vectors\n\nExamples\n\njulia> â„¬, ğâ‚, ğâ‚‚, ğâ‚ƒ = init_canonical()\n(Sym[1 0 0; 0 1 0; 0 0 1], Sym[1, 0, 0], Sym[0, 1, 0], Sym[0, 0, 1])\n\n\n\n\n\n","category":"function"},{"location":"#TensND.init_cylindrical-Tuple{Any}","page":"Home","title":"TensND.init_cylindrical","text":"init_cylindrical(Î¸ ; canonical = false)\n\nReturns the angle, the cylindrical basis and the 3 unit vectors\n\nExamples\n\njulia> Î¸, â„¬á¶œ, ğÊ³, ğá¶¿, ğá¶» = init_cylindrical(symbols(\"Î¸\", real = true)) ;\n\n\n\n\n\n","category":"method"},{"location":"#TensND.init_isotropic","page":"Home","title":"TensND.init_isotropic","text":"init_isotropic(T::Type{<:Number} = Sym)\n\nReturns the isotropic tensors\n\nExamples\n\njulia> ğŸ, ğŸ™, ğ•€, ğ•, ğ•‚ = init_isotropic() ;\n\n\n\n\n\n","category":"function"},{"location":"#TensND.init_polar-Tuple{Any}","page":"Home","title":"TensND.init_polar","text":"init_polar(Î¸ ; canonical = false)\n\nReturns the angle, the polar basis and the 2 unit vectors\n\nExamples\n\njulia> Î¸, â„¬áµ–, ğÊ³, ğá¶¿ = init_polar(symbols(\"Î¸\", real = true)) ;\n\n\n\n\n\n","category":"method"},{"location":"#TensND.init_rotated-Tuple{Any, Any, Any}","page":"Home","title":"TensND.init_rotated","text":"init_rotated(Î¸, Ï•, Ïˆ; canonical = false)\n\nReturns the angles, the ratated basis and the 3 unit vectors\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ, â„¬Ê³, ğá¶¿, ğáµ , ğÊ³ = init_rotated(symbols(\"Î¸ Ï• Ïˆ\", real = true)...) ;\n\n\n\n\n\n","category":"method"},{"location":"#TensND.init_spherical-Tuple{Any, Any}","page":"Home","title":"TensND.init_spherical","text":"init_spherical(Î¸, Ï•; canonical = false)\n\nReturns the angles, the spherical basis and the 3 unit vectors. Take care that the order of the 3 vectors is ğá¶¿, ğáµ , ğÊ³ so that the basis coincides with the canonical one when the angles are null.\n\nExamples\n\njulia> Î¸, Ï•, â„¬Ë¢, ğá¶¿, ğáµ , ğÊ³ = init_spherical(symbols(\"Î¸ Ï•\", real = true)...) ;\n\n\n\n\n\n","category":"method"},{"location":"#TensND.invKM-Tuple{Type{var\"#s21\"} where var\"#s21\"<:(Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}), AbstractVecOrMat{T} where T}","page":"Home","title":"TensND.invKM","text":"invKM(v::AbstractVecOrMat; kwargs...)\n\nDefines a tensor from a Kelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"#TensND.isorthogonal-Tuple{AbstractBasis}","page":"Home","title":"TensND.isorthogonal","text":"isorthogonal(â„¬::AbstractBasis)\n\nChecks whether the basis â„¬ is orthogonal\n\n\n\n\n\n","category":"method"},{"location":"#TensND.isorthonormal-Tuple{AbstractBasis}","page":"Home","title":"TensND.isorthonormal","text":"isorthonormal(â„¬::AbstractBasis)\n\nChecks whether the basis â„¬ is orthonormal\n\n\n\n\n\n","category":"method"},{"location":"#TensND.metric-Tuple{AbstractBasis, Val{:cov}}","page":"Home","title":"TensND.metric","text":"metric(â„¬::AbstractBasis, var = :cov)\n\nReturns the covariant (if var = :cov) or contravariant (if var = :cont) metric matrix\n\n\n\n\n\n","category":"method"},{"location":"#TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T<:Number, A<:AbstractArray}}} where {order1, order2, dim}","page":"Home","title":"TensND.otimesul","text":"otimesul(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a special tensor product between two tensors of at least second order\n\n(ğš âŠ Ë¢ ğ›) âŠ¡ ğ© = (ğš âŠ  ğ›) âŠ¡ (ğ© + áµ—ğ©)/2  = 1/2(aâ±áµbÊ²Ë¡+aâ±Ë¡bÊ²áµ) pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#TensND.qcontract-Union{Tuple{order2}, Tuple{order1}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, order1}, AbstractArray{T2, order2}}} where {T1, T2, order1, order2}","page":"Home","title":"TensND.qcontract","text":"dcontract(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a quadruple contracted product between two tensors\n\nğ”¸ âŠ™ ğ”¹ = Aáµ¢â±¼â‚–â‚—Bâ±Ê²áµË¡\n\nExamples\n\njulia> ğ•€ = tğ•€(Sym) ; ğ• = tğ•(Sym) ; ğ•‚ = tğ•‚(Sym) ;\n\njulia> ğ•€ âŠ™ ğ•€\n6\n\njulia> ğ• âŠ™ ğ•€\n1\n\njulia> ğ•‚ âŠ™ ğ•€\n5\n\njulia> ğ•‚ âŠ™ ğ•\n0\n\n\n\n\n\n","category":"method"},{"location":"#TensND.rot2-Tuple{Any}","page":"Home","title":"TensND.rot2","text":"rot2(Î¸)\n\nReturns a 2D rotation matrix with respect to the angle Î¸\n\nExamples\n\njulia> rot2(Î¸)\n2Ã—2 Tensor{2, 2, Sym, 4}:\n cos(Î¸)  -sin(Î¸)\n sin(Î¸)   cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.rot3","page":"Home","title":"TensND.rot3","text":"rot3(Î¸, Ï• = 0, Ïˆ = 0)\n\nReturns a rotation matrix with respect to the 3 Euler angles Î¸, Ï•, Ïˆ\n\nExamples\n\njulia> cÎ¸, cÏ•, cÏˆ, sÎ¸, sÏ•, sÏˆ = symbols(\"cÎ¸ cÏ• cÏˆ sÎ¸ sÏ• sÏˆ\", real = true) ;\n\njulia> d = Dict(cos(Î¸) => cÎ¸, cos(Ï•) => cÏ•, cos(Ïˆ) => cÏˆ, sin(Î¸) => sÎ¸, sin(Ï•) => sÏ•, sin(Ïˆ) => sÏˆ) ;\n\njulia> subs.(rot3(Î¸, Ï•, Ïˆ),d...)\n3Ã—3 StaticArrays.SMatrix{3, 3, Sym, 9} with indices SOneTo(3)Ã—SOneTo(3):\n cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•  -cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•  cÏ•â‹…sÎ¸\n cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ  -cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•  sÎ¸â‹…sÏ•\n           -cÏˆâ‹…sÎ¸              sÎ¸â‹…sÏˆ     cÎ¸\n\n\n\n\n\n","category":"function"},{"location":"#TensND.rot6","page":"Home","title":"TensND.rot6","text":"rot6(Î¸, Ï• = 0, Ïˆ = 0)\n\nReturns a rotation matrix with respect to the 3 Euler angles Î¸, Ï•, Ïˆ\n\nExamples\n\njulia> cÎ¸, cÏ•, cÏˆ, sÎ¸, sÏ•, sÏˆ = symbols(\"cÎ¸ cÏ• cÏˆ sÎ¸ sÏ• sÏˆ\", real = true) ;\n\njulia> d = Dict(cos(Î¸) => cÎ¸, cos(Ï•) => cÏ•, cos(Ïˆ) => cÏˆ, sin(Î¸) => sÎ¸, sin(Ï•) => sÏ•, sin(Ïˆ) => sÏˆ) ;\n\njulia> R = Tensnd(subs.(rot3(Î¸, Ï•, Ïˆ),d...))\nTensND.TensndCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•  -cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•  cÏ•â‹…sÎ¸\n cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ  -cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•  sÎ¸â‹…sÏ•\n           -cÏˆâ‹…sÎ¸              sÎ¸â‹…sÏˆ     cÎ¸\n# var: (:cont, :cont)\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> RR = R âŠ Ë¢ R\nTensND.TensndCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6Ã—6 Matrix{Sym}:\n                          (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)^2                            (-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)^2           cÏ•^2*sÎ¸^2                      âˆš2â‹…cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)                     âˆš2â‹…cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)\n                          (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)^2                            (-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•)^2           sÎ¸^2*sÏ•^2                      âˆš2â‹…sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)                     âˆš2â‹…sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)\n                                     cÏˆ^2*sÎ¸^2                                        sÎ¸^2*sÏˆ^2                cÎ¸^2                                       âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏˆ                                    -âˆš2â‹…cÎ¸â‹…cÏˆâ‹…sÎ¸                                                              -sqrt(2)*cÏˆ*sÎ¸^2*sÏˆ\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)    âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏ•                    cÎ¸*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + sÎ¸^2*sÏˆ*sÏ•                   cÎ¸*(cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ) - cÏˆ*sÎ¸^2*sÏ•                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)    âˆš2â‹…cÎ¸â‹…cÏ•â‹…sÎ¸                    cÎ¸*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•) + cÏ•*sÎ¸^2*sÏˆ                   cÎ¸*(cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•) - cÏˆ*cÏ•*sÎ¸^2                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)\n âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)  âˆš2â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)  sqrt(2)*cÏ•*sÎ¸^2*sÏ•  cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)  cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ) + sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)  (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 = invKM(subs.(KM(rot6(Î¸, Ï•, Ïˆ)),d...))\nTensND.TensndCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6Ã—6 Matrix{Sym}:\n                          (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)^2                            (-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)^2           cÏ•^2*sÎ¸^2                      âˆš2â‹…cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)                     âˆš2â‹…cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)\n                          (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)^2                            (-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•)^2           sÎ¸^2*sÏ•^2                      âˆš2â‹…sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)                     âˆš2â‹…sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)\n                                     cÏˆ^2*sÎ¸^2                                        sÎ¸^2*sÏˆ^2                cÎ¸^2                                       âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏˆ                                    -âˆš2â‹…cÎ¸â‹…cÏˆâ‹…sÎ¸                                                              -sqrt(2)*cÏˆ*sÎ¸^2*sÏˆ\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)    âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏ•                    cÎ¸*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + sÎ¸^2*sÏˆ*sÏ•                   cÎ¸*(cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ) - cÏˆ*sÎ¸^2*sÏ•                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)    âˆš2â‹…cÎ¸â‹…cÏ•â‹…sÎ¸                    cÎ¸*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•) + cÏ•*sÎ¸^2*sÏˆ                   cÎ¸*(cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•) - cÏˆ*cÏ•*sÎ¸^2                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)\n âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)  âˆš2â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)  sqrt(2)*cÏ•*sÎ¸^2*sÏ•  cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)  cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ) + sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)  (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 == RR\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T<:Number, A<:AbstractArray}}} where {order1, order2, dim}","page":"Home","title":"TensND.sotimes","text":"sotimes(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a symmetric tensor product between two tensors\n\n(aâ±eáµ¢) âŠ—Ë¢ (bÊ²eâ±¼) = 1/2(aâ±bÊ² + aÊ²bâ±) eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#TensND.tensId2","page":"Home","title":"TensND.tensId2","text":"tensId2(T::Type{<:Number} = Sym, dim = 3)\ntğŸ(T::Type{<:Number} = Sym, dim = 3)\n\nIdentity tensor of second order ğŸáµ¢â±¼ = Î´áµ¢â±¼ = 1 if i=j otherwise 0\n\nExamples\n\njulia> ğŸ = tğŸ() ; KM(ğŸ)\n6-element Vector{Sym}:\n 1\n 1\n 1\n 0\n 0\n 0\n\njulia> ğŸ.data\n3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensId4","page":"Home","title":"TensND.tensId4","text":"tensId4(T::Type{<:Number} = Sym, dim = 3)\ntğŸ™(T::Type{<:Number} = Sym, dim = 3)\n\nIdentity tensor of fourth order  ğŸ™ = ğŸ âŠ  ğŸ i.e. (ğŸ™)áµ¢â±¼â‚–â‚— = Î´áµ¢â‚–Î´â±¼â‚—\n\nExamples\n\njulia> ğŸ™ = tğŸ™() ; KM(ğŸ™)\n9Ã—9 Matrix{Sym}:\n 1  0  0  0  0  0  0  0  0\n 0  1  0  0  0  0  0  0  0\n 0  0  1  0  0  0  0  0  0\n 0  0  0  1  0  0  0  0  0\n 0  0  0  0  1  0  0  0  0\n 0  0  0  0  0  1  0  0  0\n 0  0  0  0  0  0  1  0  0\n 0  0  0  0  0  0  0  1  0\n 0  0  0  0  0  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensId4s","page":"Home","title":"TensND.tensId4s","text":"tensId4s(T::Type{<:Number} = Sym, dim = 3)\ntğ•€(T::Type{<:Number} = Sym, dim = 3)\n\nSymmetric identity tensor of fourth order  ğ•€ = ğŸ âŠ Ë¢ ğŸ i.e. (ğ•€)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2\n\nExamples\n\njulia> ğ•€ = tğ•€() ; KM(ğ•€)\n6Ã—6 Matrix{Sym}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  0  1  0  0\n 0  0  0  0  1  0\n 0  0  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensJ4","page":"Home","title":"TensND.tensJ4","text":"tensJ4(T::Type{<:Number} = Sym, dim = 3)\ntğ•(T::Type{<:Number} = Sym, dim = 3)\n\nSpherical projector of fourth order  ğ• = (ğŸ âŠ— ğŸ) / dim i.e. (ğ•)áµ¢â±¼â‚–â‚— = Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ• = tğ•() ; KM(ğ•)\n6Ã—6 Matrix{Sym}:\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensK4","page":"Home","title":"TensND.tensK4","text":"tensK4(T::Type{<:Number} = Sym, dim = 3)\ntğ•‚(T::Type{<:Number} = Sym, dim = 3)\n\nDeviatoric projector of fourth order  ğ•‚ = ğ•€ - ğ• i.e. (ğ•‚)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2 - Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ•‚ = tğ•‚() ; KM(ğ•‚)\n6Ã—6 Matrix{Sym}:\n  2/3  -1/3  -1/3  0  0  0\n -1/3   2/3  -1/3  0  0  0\n -1/3  -1/3   2/3  0  0  0\n    0     0     0  1  0  0\n    0     0     0  0  1  0\n    0     0     0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.vecbasis-Tuple{AbstractBasis, Val{:cov}}","page":"Home","title":"TensND.vecbasis","text":"vecbasis(â„¬::AbstractBasis, var = :cov)\n\nReturns the primal (if var = :cov) or primal (if var = :cont) basis\n\n\n\n\n\n","category":"method"},{"location":"#TensND.âˆ‚-Union{Tuple{A}, Tuple{dim}, Tuple{order}, Tuple{TensND.AbstractTensnd{order, dim, Sym, A}, Sym}} where {order, dim, A}","page":"Home","title":"TensND.âˆ‚","text":"âˆ‚(t::AbstractTensnd{order,dim,Sym,A},xáµ¢::Sym)\n\nReturns the derivative of the tensor t with respect to the variable x_i\n\nExamples\n\n\njulia> Î¸, Ï•, â„¬Ë¢, ğá¶¿, ğáµ , ğÊ³ = init_spherical(symbols(\"Î¸ Ï•\", real = true)...) ;\n\njulia> âˆ‚(ğÊ³, Ï•) == sin(Î¸) * ğáµ \ntrue\n\njulia> âˆ‚(ğÊ³ âŠ— ğÊ³,Î¸)\nTensND.TensndRotated{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 0  0  1\n 0  0  0\n 1  0  0\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\n# var: (:cont, :cont)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğ","page":"Home","title":"TensND.ğ","text":"ğ(i::Int, dim::Int = 3, T::Type{<:Number} = Sym)\n\nVector of the canonical basis\n\nExamples\n\njulia> ğ(1)\nTensnd{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.ğË¢-Union{Tuple{Val{1}}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Val{1}, T1}, Tuple{Val{1}, T1, T2}, Tuple{Val{1}, T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Home","title":"TensND.ğË¢","text":"ğË¢(i::Int, Î¸::T = zero(Sym), Ï•::T = zero(Sym), Ïˆ::T = zero(Sym); canonical = false)\n\nVector of the basis rotated with the 3 Euler angles Î¸, Ï•, Ïˆ (spherical if Ïˆ=0)\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ;\n\nTensnd{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğáµ–-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"Home","title":"TensND.ğáµ–","text":"ğáµ–(i::Int, Î¸::T = zero(Sym); canonical = false)\n\nVector of the polar basis\n\nExamples\n\njulia> Î¸ = symbols(\"Î¸\", real = true) ;\n\njulia> ğáµ–(1, Î¸)\nTensnd{1, 2, Sym, Sym, Vec{2, Sym}, RotatedBasis{2, Sym}}\n# data: 2-element Vec{2, Sym}:\n 1\n 0\n# var: (:cont,)\n# basis: 2Ã—2 Tensor{2, 2, Sym, 4}:\n cos(Î¸)  -sin(Î¸)\n sin(Î¸)   cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğá¶œ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"Home","title":"TensND.ğá¶œ","text":"ğá¶œ(i::Int, Î¸::T = zero(Sym); canonical = false)\n\nVector of the cylindrical basis\n\nExamples\n\njulia> Î¸ = symbols(\"Î¸\", real = true) ;\n\njulia> ğá¶œ(1, Î¸)\nTensnd{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)  -sin(Î¸)  0\n sin(Î¸)   cos(Î¸)  0\n      0        0  1\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T<:Number, A<:AbstractArray}}} where {order1, order2, dim}","page":"Home","title":"Tensors.dcontract","text":"dcontract(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a double contracted product between two tensors\n\nğ›” âŠ¡ ğ›† = Ïƒâ±Ê²Îµáµ¢â±¼ ğ›” = â„‚ âŠ¡ ğ›†\n\nExamples\n\njulia> ğ›† = Tensnd(SymmetricTensor{2,3}((i, j) -> symbols(\"Îµ$i$j\", real = true))) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> ğ›” = â„‚ âŠ¡ ğ›†\nTensnd{2, 3, Sym, Sym, SymmetricTensor{2, 3, Sym, 6}, CanonicalBasis{3, Sym}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n Îµ11*(k + 4*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ21â‹…Î¼                                              2â‹…Îµ31â‹…Î¼\n                                             2â‹…Îµ21â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k + 4*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ32â‹…Î¼\n                                             2â‹…Îµ31â‹…Î¼                                              2â‹…Îµ32â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k + 4*Î¼/3)\n# var: (:cont, :cont)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{orderS, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T<:Number, A<:AbstractArray}}} where {order1, orderS, order2, dim}","page":"Home","title":"Tensors.dotdot","text":"dotdot(v1::AbstractTensnd{order1,dim}, S::AbstractTensnd{orderS,dim}, v2::AbstractTensnd{order2,dim})\n\nDefines a bilinear operator ğ¯â‚â‹…ğ•Šâ‹…ğ¯â‚‚\n\nExamples\n\njulia> n = Tensnd(Sym[0, 0, 1]) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> dotdot(n,â„‚,n) # Acoustic tensor\n3Ã—3 Tensnd{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}:\n Î¼  0          0\n 0  Î¼          0\n 0  0  k + 4*Î¼/3\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T<:Number, A<:AbstractArray}}} where {order1, order2, dim}","page":"Home","title":"Tensors.otimes","text":"otimes(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a tensor product between two tensors\n\n(aâ±eáµ¢) âŠ— (bÊ²eâ±¼) = aâ±bÊ² eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T<:Number, A<:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T<:Number, A<:AbstractArray}}} where {order1, order2, dim}","page":"Home","title":"Tensors.otimesu","text":"otimesu(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a special tensor product between two tensors of at least second order\n\n(ğš âŠ  ğ›) âŠ¡ ğ© = ğšâ‹…ğ©â‹…ğ› = aâ±áµbÊ²Ë¡pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"}]
}
