var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensND","category":"page"},{"location":"#TensND","page":"Home","title":"TensND","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TensND.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TensND]","category":"page"},{"location":"#TensND.Ïµ","page":"Home","title":"TensND.Ïµ","text":"Ïµ[i,j,k]\n\nLevi-Civita symbol Ïµáµ¢â±¼â‚–=(i-j)(j-k)(k-i)/2\n\n\n\n\n\n","category":"constant"},{"location":"#TensND.Basis","page":"Home","title":"TensND.Basis","text":"Basis(v::AbstractArray{T,2}, ::Val{:cov})\nBasis{dim, T<:Number}()\nBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\n\nBasis built from a square matrix v where columns correspond either to\n\nprimal vectors ie eáµ¢=v[:,i] if var=:cov as by default\ndual vectors ie eâ±=v[:,i] if var=:cont.\n\nBasis without any argument refers to the canonical basis (CanonicalBasis) in Ráµˆâ±áµ (by default dim=3 and T=Sym)\n\nBasis can also be built from Euler angles (RotatedBasis) Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nThe attributes of this object are\n\nBasis.e: square matrix defining the primal basis eáµ¢=e[:,i]\nBasis.E: square matrix defining the dual basis eâ±=E[:,i]\nBasis.g: square matrix defining the covariant components of the metric tensor gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]\nBasis.G: square matrix defining the contravariant components of the metric tensor gâ±Ê²=eâ±â‹…eÊ²=G[i,j]\n\nExamples\n\njulia> v = Sym[1 0 0; 0 1 0; 0 1 1] ; b = Basis(v)\nBasis{3, Sym}\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# dual basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0   0\n 0  1  -1\n 0  0   1\n# covariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# contravariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1   0   0\n 0   1  -1\n 0  -1   2\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; b = Basis(Î¸, Ï•, Ïˆ) ; display(b.e)\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"#TensND.CanonicalBasis","page":"Home","title":"TensND.CanonicalBasis","text":"CanonicalBasis{dim, T}\n\nCanonical basis of dimension dim (default: 3) and type T (default: Sym)\n\nThe attributes of this object are\n\nBasis.e: identity matrix defining the primal basis e[i,j]=Î´áµ¢â±¼\nBasis.E: identity matrix defining the dual basis g[i,j]=Î´áµ¢â±¼\nBasis.g: identity matrix defining the covariant components of the metric tensor g[i,j]=Î´áµ¢â±¼\nBasis.G: identity matrix defining the contravariant components of the metric tensor G[i,j]=Î´áµ¢â±¼\n\nExamples\n\njulia> b = CanonicalBasis()\nCanonicalBasis{3, SymPy.Sym}\n# basis: 3Ã—3 Tensors.Tensor{2, 3, SymPy.Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n# dual basis: 3Ã—3 Tensors.Tensor{2, 3, SymPy.Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n# covariant metric tensor: 3Ã—3 Tensors.SymmetricTensor{2, 3, SymPy.Sym, 6}:\n 1  0  0\n 0  1  0\n 0  0  1\n# contravariant metric tensor: 3Ã—3 Tensors.SymmetricTensor{2, 3, SymPy.Sym, 6}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> b = CanonicalBasis{2, Float64}()\nCanonicalBasis{2, Float64}\n# basis: 2Ã—2 Tensors.Tensor{2, 2, Float64, 4}:\n 1.0  0.0\n 0.0  1.0\n# dual basis: 2Ã—2 Tensors.Tensor{2, 2, Float64, 4}:\n 1.0  0.0\n 0.0  1.0\n# covariant metric tensor: 2Ã—2 Tensors.SymmetricTensor{2, 2, Float64, 3}:\n 1.0  0.0\n 0.0  1.0\n# contravariant metric tensor: 2Ã—2 Tensors.SymmetricTensor{2, 2, Float64, 3}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"#TensND.RotatedBasis","page":"Home","title":"TensND.RotatedBasis","text":"RotatedBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\nRotatedBasis(Î¸::T<:Number)\n\nOrthonormal basis of dimension dim (default: 3) and type T (default: Sym) built from Euler angles Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; b = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(b.e)\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"#TensND.Tensnd","page":"Home","title":"TensND.Tensnd","text":"Tensnd{order,dim,TA<:Number,TB<:Number,A<:AbstractArray,B<:AbstractBasis}\n\nTensor type of any order defined by\n\na multiarray of components (of any type heriting from AbstractArray, e.g. Tensor or SymmetricTensor)\na basis of AbstractBasis type\na tuple of variances (covariant :cov or contravariant :cont) of length equal to the order of the tensor\n\nExamples\n\njulia> v = Sym[1 0 0; 0 1 0; 0 1 1] ; b = Basis(v) ;\n\njulia> T = Tensnd(b.g,(:cov,:cov),b)\nTensnd{2, 3, Sym, Sym, SymmetricTensor{2, 3, Sym, 6}, Basis{3, Sym}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# var: (:cov, :cov)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n\njulia> components(T,(:cont,:cov),b)\n3Ã—3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"type"},{"location":"#LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{order2, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}}} where {order1, order2, dim}","page":"Home","title":"LinearAlgebra.dot","text":"dot(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a contracted product between two tensors\n\na â‹… b = aâ±bâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize","page":"Home","title":"LinearAlgebra.normalize","text":"normalize(b::AbstractBasis, var = cov)\n\nBuilds a normalized basis from the input basis b by calling normal_basis\n\n\n\n\n\n","category":"function"},{"location":"#TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}}","page":"Home","title":"TensND.KM","text":"KM(t::AbstractTensnd{order,dim}; kwargs...)\nKM(t::AbstractTensnd{order,dim}, var::NTuple{order,Symbol}, b::AbstractBasis{dim}; kwargs...)\n\nWrites the components of a second or fourth order tensor in Kelvin-Mandel notation\n\nExamples\n\njulia> Ïƒ = Tensnd(SymmetricTensor{2,3}((i, j) -> symbols(\"Ïƒ$i$j\", real = true))) ;\n\njulia> KM(Ïƒ)\n6-element Vector{Sym}:\n         Ïƒ11\n         Ïƒ22\n         Ïƒ33\n      âˆš2â‹…Ïƒ32\n      âˆš2â‹…Ïƒ31\n      âˆš2â‹…Ïƒ21\n\njulia> C = Tensnd(SymmetricTensor{4,3}((i, j, k, l) -> symbols(\"C$i$j$k$l\", real = true))) ;\n\njulia> KM(C)\n6Ã—6 Matrix{Sym}:\n         Câ‚â‚â‚â‚     Câ‚â‚â‚‚â‚‚     Câ‚â‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚â‚â‚ƒâ‚‚  âˆš2â‹…Câ‚â‚â‚ƒâ‚  âˆš2â‹…Câ‚â‚â‚‚â‚\n         Câ‚‚â‚‚â‚â‚     Câ‚‚â‚‚â‚‚â‚‚     Câ‚‚â‚‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚‚  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚  âˆš2â‹…Câ‚‚â‚‚â‚‚â‚\n         Câ‚ƒâ‚ƒâ‚â‚     Câ‚ƒâ‚ƒâ‚‚â‚‚     Câ‚ƒâ‚ƒâ‚ƒâ‚ƒ  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚‚â‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚â‚‚â‚\n      âˆš2â‹…Câ‚‚â‚â‚â‚  âˆš2â‹…Câ‚‚â‚â‚‚â‚‚  âˆš2â‹…Câ‚‚â‚â‚ƒâ‚ƒ   2â‹…Câ‚‚â‚â‚ƒâ‚‚   2â‹…Câ‚‚â‚â‚ƒâ‚   2â‹…Câ‚‚â‚â‚‚â‚\n\n\n\n\n\n","category":"method"},{"location":"#TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"TensND.angles","text":"angles(M::AbstractArray{T,2})\n\nDetermines the Euler angles corresponding to the input matrix supposed to be a rotation matrix or at least a similarity\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; b = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(b.e)\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\njulia> angles(b)\n(Î¸ = Î¸, Ï• = Ï•, Ïˆ = Ïˆ)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.components-Union{Tuple{T}, Tuple{dim}, Tuple{order}, Tuple{Tensnd{order, dim, T, TB, A, B} where {TB, A, B}, Tuple{Vararg{Symbol, order}}}} where {order, dim, T<:Number}","page":"Home","title":"TensND.components","text":"components(::Tensnd{order,dim,T}, ::NTuple{order,Symbol})\ncomponents(::Tensnd{order,dim,T}, ::NTuple{order,Symbol}, ::AbstractBasis{dim,T})\ncomponents(::Tensnd{order,dim,T}, ::AbstractBasis{dim,T})\n\nExtracts the components of a tensor for new variances and/or in a new basis\n\nExamples\n\njulia> v = Sym[0 1 1; 1 0 1; 1 1 0] ; b = Basis(v) ;\n\njulia> V = Tensor{1,3}(i->symbols(\"v$i\",real=true))\n3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n\njulia> TV = Tensnd(V) # TV = Tensnd(V, (:cont,), CanonicalBasis())\nTensnd{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> factor.(components(TV, (:cont,), b))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> components(TV, (:cov,), b)\n3-element Vector{Sym}:\n vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚\n\njulia> simplify.(components(TV, (:cov,), normal_basis(b)))\n3-element Vector{Sym}:\n sqrt(2)*(v2 + v3)/2\n sqrt(2)*(v1 + v3)/2\n sqrt(2)*(v1 + v2)/2\n\njulia> T = Tensor{2,3}((i,j)->symbols(\"t$i$j\",real=true))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n tâ‚â‚  tâ‚â‚‚  tâ‚â‚ƒ\n tâ‚‚â‚  tâ‚‚â‚‚  tâ‚‚â‚ƒ\n tâ‚ƒâ‚  tâ‚ƒâ‚‚  tâ‚ƒâ‚ƒ\n\njulia> TT = Tensnd(T)\nTensnd{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}\n# data: 3Ã—3 Tensor{2, 3, Sym, 9}:\n tâ‚â‚  tâ‚â‚‚  tâ‚â‚ƒ\n tâ‚‚â‚  tâ‚‚â‚‚  tâ‚‚â‚ƒ\n tâ‚ƒâ‚  tâ‚ƒâ‚‚  tâ‚ƒâ‚ƒ\n# var: (:cont, :cont)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> components(TT, (:cov,:cov), b)\n3Ã—3 Matrix{Sym}:\n tâ‚‚â‚‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚‚â‚‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚‚â‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚‚â‚ + tâ‚‚â‚‚\n\njulia> factor.(components(TT, (:cont,:cov), b))\n3Ã—3 Matrix{Sym}:\n -(t12 + t13 - t22 - t23 - t32 - t33)/2  â€¦  -(t11 + t12 - t21 - t22 - t31 - t32)/2\n  (t12 + t13 - t22 - t23 + t32 + t33)/2      (t11 + t12 - t21 - t22 + t31 + t32)/2\n  (t12 + t13 + t22 + t23 - t32 - t33)/2      (t11 + t12 + t21 + t22 - t31 - t32)/2\n\n\n\n\n\n","category":"method"},{"location":"#TensND.fÏµ-Union{Tuple{Int64, Int64, Int64}, Tuple{T}, Tuple{Int64, Int64, Int64, Type{var\"#s16\"} where var\"#s16\"<:T}} where T","page":"Home","title":"TensND.fÏµ","text":"fÏµ(T, i::Int, j::Int, k::Int)\nfÏµ(i::Int, j::Int, k::Int) = fÏµ(Int, i::Int, j::Int, k::Int)\n\nFunction giving Levi-Civita symbol Ïµáµ¢â±¼â‚– = (i-j) (j-k) (k-i) / 2\n\n\n\n\n\n","category":"method"},{"location":"#TensND.invKM-Tuple{Type{var\"#s17\"} where var\"#s17\"<:(Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}), AbstractVecOrMat{T} where T}","page":"Home","title":"TensND.invKM","text":"invKM(v::AbstractVecOrMat; kwargs...)\n\nDefines a tensor from a Kelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"#TensND.isorthogonal-Union{Tuple{AbstractBasis{dim, T}}, Tuple{T}, Tuple{dim}} where {dim, T}","page":"Home","title":"TensND.isorthogonal","text":"isorthogonal(b::AbstractBasis)\n\nChecks whether the basis b is orthogonal\n\n\n\n\n\n","category":"method"},{"location":"#TensND.isorthonormal-Union{Tuple{AbstractBasis{dim, T}}, Tuple{T}, Tuple{dim}} where {dim, T}","page":"Home","title":"TensND.isorthonormal","text":"isorthonormal(b::AbstractBasis)\n\nChecks whether the basis b is orthonormal\n\n\n\n\n\n","category":"method"},{"location":"#TensND.metric-Tuple{AbstractBasis, Val{:cov}}","page":"Home","title":"TensND.metric","text":"metric(b::AbstractBasis, var = :cov)\n\nReturns the covariant (if var = :cov) or contravariant (if var = :cont) metric matrix\n\n\n\n\n\n","category":"method"},{"location":"#TensND.normal_basis-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"Home","title":"TensND.normal_basis","text":"normal_basis(v::AbstractArray{T,2}, var = :cov) where {T}\n\nBuilds a basis after normalization of column vectors of input matrix v where columns define either\n\nprimal vectors ie eáµ¢=v[:,i]/norm(v[:,i]) if var = :cov as by default\ndual vector ie eâ±=v[:,i]/norm(v[:,i]) if var = :cont.\n\n\n\n\n\n","category":"method"},{"location":"#TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{order2, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}}} where {order1, order2, dim}","page":"Home","title":"TensND.otimesul","text":"otimesul(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a special tensor product between two tensors of at least second order\n\n(ğš âŠ Ë¢ ğ›) âŠ¡ ğ© = (ğš âŠ  ğ›) âŠ¡ (ğ© + áµ—ğ©)/2  = 1/2(aâ±áµbÊ²Ë¡+aâ±Ë¡bÊ²áµ) pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#TensND.qcontract-Union{Tuple{order2}, Tuple{order1}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, order1}, AbstractArray{T2, order2}}} where {T1, T2, order1, order2}","page":"Home","title":"TensND.qcontract","text":"dcontract(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a quadruple contracted product between two tensors\n\nğ”¸ âŠ™ ğ”¹ = Aáµ¢â±¼â‚–â‚—Bâ±Ê²áµË¡\n\nExamples\n\njulia> ğ•€ = tğ•€(Sym) ; ğ• = tğ•(Sym) ; ğ•‚ = tğ•‚(Sym) ;\n\njulia> ğ•€ âŠ™ ğ•€\n6\n\njulia> ğ• âŠ™ ğ•€\n1\n\njulia> ğ•‚ âŠ™ ğ•€\n5\n\njulia> ğ•‚ âŠ™ ğ•\n0\n\n\n\n\n\n","category":"method"},{"location":"#TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{order2, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}}} where {order1, order2, dim}","page":"Home","title":"TensND.sotimes","text":"sotimes(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a symmetric tensor product between two tensors\n\n(aâ±eáµ¢) âŠ—Ë¢ (bÊ²eâ±¼) = 1/2(aâ±bÊ² + aÊ²bâ±) eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#TensND.tensId2","page":"Home","title":"TensND.tensId2","text":"tensId2(T::Type{<:Number} = Sym, dim = 3)\ntğŸ(T::Type{<:Number} = Sym, dim = 3)\n\nIdentity tensor of second order ğŸáµ¢â±¼ = Î´áµ¢â±¼ = 1 if i=j otherwise 0\n\nExamples\n\njulia> ğŸ = tğŸ() ; KM(ğŸ)\n6-element Vector{Sym}:\n 1\n 1\n 1\n 0\n 0\n 0\n\njulia> ğŸ.data\n3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensId4","page":"Home","title":"TensND.tensId4","text":"tensId4(T::Type{<:Number} = Sym, dim = 3)\ntğŸ™(T::Type{<:Number} = Sym, dim = 3)\n\nIdentity tensor of fourth order  ğŸ™ = ğŸ âŠ  ğŸ i.e. (ğŸ™)áµ¢â±¼â‚–â‚— = Î´áµ¢â‚–Î´â±¼â‚—\n\nExamples\n\njulia> ğŸ™ = tğŸ™() ; KM(ğŸ™)\n9Ã—9 Matrix{Sym}:\n 1  0  0  0  0  0  0  0  0\n 0  1  0  0  0  0  0  0  0\n 0  0  1  0  0  0  0  0  0\n 0  0  0  1  0  0  0  0  0\n 0  0  0  0  1  0  0  0  0\n 0  0  0  0  0  1  0  0  0\n 0  0  0  0  0  0  1  0  0\n 0  0  0  0  0  0  0  1  0\n 0  0  0  0  0  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensId4s","page":"Home","title":"TensND.tensId4s","text":"tensId4s(T::Type{<:Number} = Sym, dim = 3)\ntğ•€(T::Type{<:Number} = Sym, dim = 3)\n\nSymmetric identity tensor of fourth order  ğ•€ = ğŸ âŠ Ë¢ ğŸ i.e. (ğ•€)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2\n\nExamples\n\njulia> ğ•€ = tğ•€() ; KM(ğ•€)\n6Ã—6 Matrix{Sym}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  0  1  0  0\n 0  0  0  0  1  0\n 0  0  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensJ4","page":"Home","title":"TensND.tensJ4","text":"tensJ4(T::Type{<:Number} = Sym, dim = 3)\ntğ•(T::Type{<:Number} = Sym, dim = 3)\n\nSpherical projector of fourth order  ğ• = (ğŸ âŠ— ğŸ) / dim i.e. (ğ•)áµ¢â±¼â‚–â‚— = Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ• = tğ•() ; KM(ğ•)\n6Ã—6 Matrix{Sym}:\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"#TensND.tensK4","page":"Home","title":"TensND.tensK4","text":"tensK4(T::Type{<:Number} = Sym, dim = 3)\ntğ•‚(T::Type{<:Number} = Sym, dim = 3)\n\nDeviatoric projector of fourth order  ğ•‚ = ğ•€ - ğ• i.e. (ğ•‚)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2 - Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ•‚ = tğ•‚() ; KM(ğ•‚)\n6Ã—6 Matrix{Sym}:\n  2/3  -1/3  -1/3  0  0  0\n -1/3   2/3  -1/3  0  0  0\n -1/3  -1/3   2/3  0  0  0\n    0     0     0  1  0  0\n    0     0     0  0  1  0\n    0     0     0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.vecbasis-Tuple{AbstractBasis, Val{:cov}}","page":"Home","title":"TensND.vecbasis","text":"vecbasis(b::AbstractBasis, var = :cov)\n\nReturns the primal (if var = :cov) or primal (if var = :cont) basis\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğ","page":"Home","title":"TensND.ğ","text":"ğ(i::Int, dim::Int = 3, T::Type{<:Number} = Sym)\n\nVector of the canonical basis\n\nExamples\n\njulia> ğ(1)\nTensnd{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"function"},{"location":"#TensND.ğp-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"Home","title":"TensND.ğp","text":"ğp(i::Int, Î¸::T = zero(Sym))\n\nVector of the polar basis\n\nExamples\n\njulia> Î¸ = symbols(\"Î¸\", real = true) ;\n\njulia> ğp(1, Î¸)\nTensnd{1, 2, Sym, Sym, Vec{2, Sym}, CanonicalBasis{2, Sym}}\n# data: 2-element Vec{2, Sym}:\n cos(Î¸)\n sin(Î¸)\n# var: (:cont,)\n# basis: 2Ã—2 Tensor{2, 2, Sym, 4}:\n 1  0\n 0  1\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{order2, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}}} where {order1, order2, dim}","page":"Home","title":"Tensors.dcontract","text":"dcontract(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a double contracted product between two tensors\n\nğ›” âŠ¡ ğ›† = Ïƒâ±Ê²Îµáµ¢â±¼ ğ›” = â„‚ âŠ¡ ğ›†\n\nExamples\n\njulia> ğ›† = Tensnd(SymmetricTensor{2,3}((i, j) -> symbols(\"Îµ$i$j\", real = true))) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> ğ›” = â„‚ âŠ¡ ğ›†\nTensnd{2, 3, Sym, Sym, SymmetricTensor{2, 3, Sym, 6}, CanonicalBasis{3, Sym}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n Îµ11*(k + 4*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ21â‹…Î¼                                              2â‹…Îµ31â‹…Î¼\n                                             2â‹…Îµ21â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k + 4*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ32â‹…Î¼\n                                             2â‹…Îµ31â‹…Î¼                                              2â‹…Îµ32â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k + 4*Î¼/3)\n# var: (:cont, :cont)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{orderS, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{order2, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}}} where {order1, orderS, order2, dim}","page":"Home","title":"Tensors.dotdot","text":"dotdot(v1::AbstractTensnd{order1,dim}, S::AbstractTensnd{orderS,dim}, v2::AbstractTensnd{order2,dim})\n\nDefines a bilinear operator ğ¯â‚â‹…ğ•Šâ‹…ğ¯â‚‚\n\nExamples\n\njulia> n = Tensnd(Sym[0, 0, 1]) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> dotdot(n,â„‚,n) # Acoustic tensor\n3Ã—3 Tensnd{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}:\n Î¼  0          0\n 0  Î¼          0\n 0  0  k + 4*Î¼/3\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{order2, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}}} where {order1, order2, dim}","page":"Home","title":"Tensors.otimes","text":"otimes(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a tensor product between two tensors\n\n(aâ±eáµ¢) âŠ— (bÊ²eâ±¼) = aâ±bÊ² eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}, TensND.AbstractTensnd{order2, dim, TA, TB, A, B} where {TA<:Number, TB<:Number, A<:AbstractArray, B<:AbstractBasis}}} where {order1, order2, dim}","page":"Home","title":"Tensors.otimesu","text":"otimesu(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})\n\nDefines a special tensor product between two tensors of at least second order\n\n(ğš âŠ  ğ›) âŠ¡ ğ© = ğšâ‹…ğ©â‹…ğ› = aâ±áµbÊ²Ë¡pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"}]
}
