var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensND","category":"page"},{"location":"#TensND","page":"Home","title":"TensND","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TensND.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TensND]","category":"page"},{"location":"#TensND.Basis","page":"Home","title":"TensND.Basis","text":"Basis(v::AbstractMatrix{T}, ::Val{:cov})\nBasis{dim, T<:Number}()\nBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\n\nBasis built from a square matrix v where columns correspond either to\n\nprimal vectors ie eáµ¢=v[:,i] if var=:cov as by default\ndual vectors ie eâ±=v[:,i] if var=:cont.\n\nBasis without any argument refers to the canonical basis (CanonicalBasis) in Ráµˆâ±áµ (by default dim=3 and T=Sym)\n\nBasis can also be built from Euler angles (RotatedBasis) Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nThe attributes of this object can be obtained by\n\nvecbasis(â„¬, :cov): square matrix defining the primal basis eáµ¢=e[:,i]\nvecbasis(â„¬, :cont): square matrix defining the dual basis eâ±=E[:,i]\nmetric(â„¬, :cov): square matrix defining the covariant components of the metric tensor gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]\nmetric(â„¬, :cont): square matrix defining the contravariant components of the metric tensor gâ±Ê²=eâ±â‹…eÊ²=gâ±Ê²[i,j]\n\nExamples\n\njulia> v = Sym[1 0 0; 0 1 0; 0 1 1] ; â„¬ = Basis(v)\nBasis{3, Sym}\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# dual basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0   0\n 0  1  -1\n 0  0   1\n# covariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# contravariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1   0   0\n 0   1  -1\n 0  -1   2\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = Basis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"#TensND.CanonicalBasis","page":"Home","title":"TensND.CanonicalBasis","text":"CanonicalBasis{dim, T}\n\nCanonical basis of dimension dim (default: 3) and type T (default: Sym)\n\nThe attributes of this object can be obtained by\n\nvecbasis(â„¬, :cov): square matrix defining the primal basis eáµ¢=e[:,i]=Î´áµ¢â±¼\nvecbasis(â„¬, :cont): square matrix defining the dual basis eâ±=E[:,i]=Î´áµ¢â±¼\nmetric(â„¬, :cov): square matrix defining the covariant components of the metric tensor gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]=Î´áµ¢â±¼\nmetric(â„¬, :cont): square matrix defining the contravariant components of the metric tensor gâ±Ê²=eâ±â‹…eÊ²=gâ±Ê²[i,j]=Î´áµ¢â±¼\n\nExamples\n\njulia> â„¬ = CanonicalBasis()\nCanonicalBasis{3, Sym}\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# dual basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# covariant metric tensor: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# contravariant metric tensor: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> â„¬â‚‚ = CanonicalBasis{2, Float64}()\nCanonicalBasis{2, Float64}\n# basis: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# dual basis: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# covariant metric tensor: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n# contravariant metric tensor: 2Ã—2 TensND.LazyIdentity{2, Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"#TensND.CoorSystemSym","page":"Home","title":"TensND.CoorSystemSym","text":"CoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},bnorm::AbstractBasis{dim,Sym},Ï‡áµ¢::NTuple{dim},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\nCoorSystemSym(OM::AbstractTens{1,dim,Sym},coords::NTuple{dim,Sym},\n              tmp_coords::NTuple = (),params::NTuple = ();rules::Dict = Dict(),tmp_var::Dict = Dict(),to_coords::Dict = Dict()) where {dim}\n\nDefines a new coordinate system either from\n\nthe position vector OM, the coordinates coords, the basis of unit vectors (ğáµ¢) bnorm and the LamÃ© coefficients Ï‡áµ¢\nIn this case the natural basis is formed by the vectors ğšáµ¢ = Ï‡áµ¢ ğáµ¢ directly calculated from the input data.\nor the position vector OM and the coordinates coords\nIn this case the natural basis is formed by the vectors ğšáµ¢ = âˆ‚áµ¢OM i.e. by the derivative of the position vector with respect to the iáµ—Ê° coordinate\n\nOptional parameters can be provided:\n\ntmp_coords contains temporary variables depending on coordinates (in order to allow symbolic simplifications)\nparams contains possible parameters involved in OM\nrules contains a Dict with substitution rules to facilitate the simplification of formulas\ntmp_var contains a Dict with substitution of coordinates by temporary variables\nto_coords indicates how to eliminate the temporary variables to come back to the actual coordinates before derivation for Examples\n\nExamples\n\njulia> Ï•, p = symbols(\"Ï• p\", real = true) ;\n\njulia> pÌ„, q, qÌ„, c = symbols(\"pÌ„ q qÌ„ c\", positive = true) ;\n\njulia> coords = (Ï•, p, q) ; tmp_coords = (pÌ„, qÌ„) ; params = (c,) ;\n\njulia> OM = Tens(c * [pÌ„ * qÌ„ * cos(Ï•), pÌ„ * qÌ„ * sin(Ï•), p * q]) ;\n\njulia> Spheroidal = CoorSystemSym(OM, coords, tmp_coords, params; tmp_var = Dict(1-p^2 => pÌ„^2, q^2-1 => qÌ„^2), to_coords = Dict(pÌ„ => âˆš(1-p^2), qÌ„ => âˆš(q^2-1))) ;\n\n\n\n\n\n","category":"type"},{"location":"#TensND.RotatedBasis","page":"Home","title":"TensND.RotatedBasis","text":"RotatedBasis(Î¸::T<:Number, Ï•::T<:Number, Ïˆ::T<:Number)\nRotatedBasis(Î¸::T<:Number)\n\nOrthonormal basis of dimension dim (default: 3) and type T (default: Sym) built from Euler angles Î¸ in 2D and (Î¸, Ï•, Ïˆ) in 3D\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"type"},{"location":"#TensND.Tens","page":"Home","title":"TensND.Tens","text":"Tens{order,dim,T,A<:AbstractArray}\n\nTensor type of any order defined by\n\na multidata of components (of any type heriting from AbstractArray, e.g. Tensor or SymmetricTensor)\na basis of AbstractBasis type\na tuple of variances (covariant :cov or contravariant :cont) of length equal to the order of the tensor\n\nExamples\n\njulia> â„¬ = Basis(Sym[1 0 0; 0 1 0; 0 1 1]) ;\n\njulia> T = Tens(metric(â„¬,:cov),â„¬,(:cov,:cov))\nTens{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  2  1\n 0  1  1\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  1  1\n# var: (:cov, :cov)\n\njulia> components(T,(:cont,:cov),b)\n3Ã—3 Matrix{Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"type"},{"location":"#LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, order2, dim}","page":"Home","title":"LinearAlgebra.dot","text":"dot(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefines a contracted product between two tensors\n\na â‹… b = aâ±bâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize","page":"Home","title":"LinearAlgebra.normalize","text":"normalize(â„¬::AbstractBasis, var = cov)\n\nBuilds a basis after normalization of column vectors of input matrix v where columns define either\n\nprimal vectors ie eáµ¢=v[:,i]/norm(v[:,i]) if var = :cov as by default\ndual vector ie eâ±=v[:,i]/norm(v[:,i]) if var = :cont.\n\n\n\n\n\n","category":"function"},{"location":"#TensND.CS_cartesian","page":"Home","title":"TensND.CS_cartesian","text":"CS_cartesian(coords = symbols(\"x y z\", real = true))\n\nReturns the cartesian coordinate system\n\nExamples\n\njulia> Cartesian = CS_cartesian() ; ğ— = getcoords(Cartesian) ; ğ„ = unitvec(Cartesian) ; â„¬ = getbasis(Cartesian)\n\njulia> ğ›” = Tens(SymmetricTensor{2,3}((i, j) -> SymFunction(\"Ïƒ$i$j\", real = true)(ğ—...))) ;\n\njulia> DIV(ğ›”, CScar)\nTens.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n Derivative(Ïƒ11(x, y, z), x) + Derivative(Ïƒ21(x, y, z), y) + Derivative(Ïƒ31(x, y, z), z)\n Derivative(Ïƒ21(x, y, z), x) + Derivative(Ïƒ22(x, y, z), y) + Derivative(Ïƒ32(x, y, z), z)\n Derivative(Ïƒ31(x, y, z), x) + Derivative(Ïƒ32(x, y, z), y) + Derivative(Ïƒ33(x, y, z), z)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\n\n\n\n\n","category":"function"},{"location":"#TensND.CS_cylindrical","page":"Home","title":"TensND.CS_cylindrical","text":"CS_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true), symbols(\"z\", real = true)); canonical = false)\n\nReturns the cylindrical coordinate system\n\nExamples\n\njulia> Cylindrical = CS_cylindrical() ; rÎ¸z = getcoords(Cylindrical) ; ğÊ³, ğá¶¿, ğá¶» = unitvec(Cylindrical) ; â„¬á¶œ = getbasis(Cylindrical)\n\njulia> ğ¯ = Tens(Vec{3}(i -> SymFunction(\"v$(rÎ¸z[i])\", real = true)(rÎ¸z...)), â„¬á¶œ) ;\n\njulia> DIV(ğ¯, Cylindrical)\n                                                  âˆ‚\n                                    vr(r, Î¸, z) + â”€â”€(vÎ¸(r, Î¸, z))\nâˆ‚                 âˆ‚                               âˆ‚Î¸\nâ”€â”€(vr(r, Î¸, z)) + â”€â”€(vz(r, Î¸, z)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâˆ‚r                âˆ‚z                              r\n\n\n\n\n\n","category":"function"},{"location":"#TensND.CS_polar","page":"Home","title":"TensND.CS_polar","text":"CS_polar(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true)); canonical = false)\n\nReturns the polar coordinate system\n\nExamples\n\njulia> Polar = CS_polar() ; r, Î¸ = getcoords(Polar) ; ğÊ³, ğá¶¿ = unitvec(Polar) ; â„¬áµ– = getbasis(Polar)\n\njulia> f = SymFunction(\"f\", real = true)(r, Î¸) ;\n\njulia> LAPLACE(f, Polar)\n                               2\n                              âˆ‚\n                             â”€â”€â”€(f(r, Î¸))\n                               2\n               âˆ‚             âˆ‚Î¸\n  2            â”€â”€(f(r, Î¸)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n âˆ‚             âˆ‚r                 r\nâ”€â”€â”€(f(r, Î¸)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  2                        r\nâˆ‚r\n\n\n\n\n\n","category":"function"},{"location":"#TensND.CS_spherical","page":"Home","title":"TensND.CS_spherical","text":"CS_spherical(coords = (symbols(\"Î¸\", real = true), symbols(\"Ï•\", real = true), symbols(\"r\", positive = true)); canonical = false)\n\nReturns the spherical coordinate system\n\nExamples\n\njulia> Spherical = CS_spherical() ; Î¸, Ï•, r = getcoords(Spherical) ; ğá¶¿, ğáµ , ğÊ³ = unitvec(Spherical) ; â„¬Ë¢ = getbasis(Spherical)\n\njulia> for Ïƒâ±Ê² âˆˆ (\"ÏƒÊ³Ê³\", \"Ïƒá¶¿á¶¿\", \"Ïƒáµ áµ \") @eval $(Symbol(Ïƒâ±Ê²)) = SymFunction($Ïƒâ±Ê², real = true)($r) end ;\n\njulia> ğ›” = ÏƒÊ³Ê³ * ğÊ³ âŠ— ğÊ³ + Ïƒá¶¿á¶¿ * ğá¶¿ âŠ— ğá¶¿ + Ïƒáµ áµ  * ğáµ  âŠ— ğáµ  ;\n\njulia> divğ›” = DIV(ğ›”, Spherical)\nTens.TensRotated{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n                              (-Ïƒáµ áµ (r) + Ïƒá¶¿á¶¿(r))*cos(Î¸)/(r*sin(Î¸))\n                                                                 0\n Derivative(ÏƒÊ³Ê³(r), r) + (ÏƒÊ³Ê³(r) - Ïƒáµ áµ (r))/r + (ÏƒÊ³Ê³(r) - Ïƒá¶¿á¶¿(r))/r\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\n# var: (:cont,)\n\njulia> divğ›” â‹… ğÊ³\nd            ÏƒÊ³Ê³(r) - Ïƒáµ áµ (r)   ÏƒÊ³Ê³(r) - Ïƒá¶¿á¶¿(r)\nâ”€â”€(ÏƒÊ³Ê³(r)) + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndr                  r                 r\n\n\n\n\n\n","category":"function"},{"location":"#TensND.CS_spheroidal","page":"Home","title":"TensND.CS_spheroidal","text":"CS_spheroidal(coords = (symbols(\"Ï•\", real = true),symbols(\"p\", real = true),symbols(\"q\", positive = true),),\n                        c = symbols(\"c\", positive = true),tmp_coords = (symbols(\"pÌ„ qÌ„\", positive = true)...,),)\n\nReturns the spheroidal coordinate system\n\nExamples\n\njulia> Spheroidal = CS_spheroidal() ; OM = getOM(Spheroidal)\nTens.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n câ‹…pÌ„â‹…qÌ„â‹…cos(Ï•)\n câ‹…pÌ„â‹…qÌ„â‹…sin(Ï•)\n          câ‹…pâ‹…q\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> LAPLACE(OM[1]^2, Spheroidal)\n2\n\n\n\n\n\n","category":"function"},{"location":"#TensND.DIV-Union{Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, Sym}, CoorSystemSym{dim, VEC, BNORM, BNAT} where {VEC, BNORM, BNAT}}} where {order, dim}","page":"Home","title":"TensND.DIV","text":"DIV(T::AbstractTens{order,dim,Sym},CS::CoorSystemSym{dim}) where {order,dim}\n\nCalculates the divergence  of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"#TensND.GRAD-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, CoorSystemSym{dim, VEC, BNORM, BNAT} where {VEC, BNORM, BNAT}}} where {order, dim}","page":"Home","title":"TensND.GRAD","text":"GRAD(T::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim}\n\nCalculates the gradient of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"#TensND.HESS-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, CoorSystemSym{dim, VEC, BNORM, BNAT} where {VEC, BNORM, BNAT}}} where {order, dim}","page":"Home","title":"TensND.HESS","text":"HESS(T::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim}\n\nCalculates the Hessian of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ISO-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"Home","title":"TensND.ISO","text":"ISO(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nReturns the three fourth-order isotropic tensors ğ•€, ğ•, ğ•‚\n\nExamples\n\njulia> ğ•€, ğ•, ğ•‚ = ISO() ;\n\n\n\n\n\n","category":"method"},{"location":"#TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}}","page":"Home","title":"TensND.KM","text":"KM(t::AbstractTens{order,dim}; kwargs...)\nKM(t::AbstractTens{order,dim}, var::NTuple{order,Symbol}, b::AbstractBasis{dim}; kwargs...)\n\nWrites the components of a second or fourth order tensor in Kelvin-Mandel notation\n\nExamples\n\njulia> Ïƒ = Tens(SymmetricTensor{2,3}((i, j) -> symbols(\"Ïƒ$i$j\", real = true))) ;\n\njulia> KM(Ïƒ)\n6-element Vector{Sym}:\n         Ïƒ11\n         Ïƒ22\n         Ïƒ33\n      âˆš2â‹…Ïƒ32\n      âˆš2â‹…Ïƒ31\n      âˆš2â‹…Ïƒ21\n\njulia> C = Tens(SymmetricTensor{4,3}((i, j, k, l) -> symbols(\"C$i$j$k$l\", real = true))) ;\n\njulia> KM(C)\n6Ã—6 Matrix{Sym}:\n         Câ‚â‚â‚â‚     Câ‚â‚â‚‚â‚‚     Câ‚â‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚â‚â‚ƒâ‚‚  âˆš2â‹…Câ‚â‚â‚ƒâ‚  âˆš2â‹…Câ‚â‚â‚‚â‚\n         Câ‚‚â‚‚â‚â‚     Câ‚‚â‚‚â‚‚â‚‚     Câ‚‚â‚‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚‚  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚  âˆš2â‹…Câ‚‚â‚‚â‚‚â‚\n         Câ‚ƒâ‚ƒâ‚â‚     Câ‚ƒâ‚ƒâ‚‚â‚‚     Câ‚ƒâ‚ƒâ‚ƒâ‚ƒ  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚‚â‚‚â‚\n      âˆš2â‹…Câ‚ƒâ‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚â‚‚â‚\n      âˆš2â‹…Câ‚‚â‚â‚â‚  âˆš2â‹…Câ‚‚â‚â‚‚â‚‚  âˆš2â‹…Câ‚‚â‚â‚ƒâ‚ƒ   2â‹…Câ‚‚â‚â‚ƒâ‚‚   2â‹…Câ‚‚â‚â‚ƒâ‚   2â‹…Câ‚‚â‚â‚‚â‚\n\n\n\n\n\n","category":"method"},{"location":"#TensND.KM-Union{Tuple{TensISO{order, dim, T, N} where {T, N}}, Tuple{dim}, Tuple{order}} where {order, dim}","page":"Home","title":"TensND.KM","text":"KM(v::AllIsotropic{dim}; kwargs...)\n\nKelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"#TensND.LAPLACE-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, CoorSystemSym{dim, VEC, BNORM, BNAT} where {VEC, BNORM, BNAT}}} where {order, dim}","page":"Home","title":"TensND.LAPLACE","text":"LAPLACE(T::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim}\n\nCalculates the Laplace operator of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"#TensND.LeviCivita","page":"Home","title":"TensND.LeviCivita","text":"LeviCivita(T::Type{<:Number} = Sym)\n\nBuilds an Array{T,3} of Levi-Civita Symbol Ïµáµ¢â±¼â‚– = (i-j) (j-k) (k-i) / 2\n\nExamples\n\njulia> Îµ = LeviCivita(Sym)\n3Ã—3Ã—3 Array{Sym, 3}:\n[:, :, 1] =\n 0   0  0\n 0   0  1\n 0  -1  0\n\n[:, :, 2] =\n 0  0  -1\n 0  0   0\n 1  0   0\n\n[:, :, 3] =\n  0  1  0\n -1  0  0\n  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"#TensND.SYMGRAD-Union{Tuple{dim}, Tuple{order}, Tuple{Union{Sym, AbstractTens{order, dim, Sym}}, CoorSystemSym{dim, VEC, BNORM, BNAT} where {VEC, BNORM, BNAT}}} where {order, dim}","page":"Home","title":"TensND.SYMGRAD","text":"SYMGRAD(T::Union{Sym,AbstractTens{order,dim,Sym}},CS::CoorSystemSym{dim}) where {order,dim}\n\nCalculates the symmetrized gradient of T with respect to the coordinate system CS\n\n\n\n\n\n","category":"method"},{"location":"#TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"TensND.angles","text":"angles(M::AbstractMatrix{T})\n\nDetermines the Euler angles corresponding to the input matrix supposed to be a rotation matrix or at least a similarity\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ; â„¬Ê³ = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(vecbasis(â„¬Ê³, :cov))\n3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\njulia> angles(â„¬Ê³)\n(Î¸ = Î¸, Ï• = Ï•, Ïˆ = Ïˆ)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.change_tens-Tuple{AbstractTens, TensND.AbstractBasis, Tuple{Vararg{T, N}} where {N, T}}","page":"Home","title":"TensND.change_tens","text":"change_tens(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim},var::NTuple{order,Symbol})\nchange_tens(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim})\nchange_tens(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nRewrites the same tensor with components corresponding to new variances and/or to a new basis\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, â„¬, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> â„¬â‚€ = Basis(Sym[0 1 1; 1 0 1; 1 1 1]) ;\n\njulia> TV0 = change_tens(TV, â„¬â‚€)\nTens{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n     -vâ‚ + vâ‚ƒ\n     -vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚‚ - vâ‚ƒ\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.change_tens_canon-Tuple{AbstractTens}","page":"Home","title":"TensND.change_tens_canon","text":"change_tens_canon(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nRewrites the same tensor with components corresponding to the canonical basis\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)), â„¬)\nTens{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 0  1  1\n 1  0  1\n 1  1  1\n# var: (:cont,)\n\njulia> TV0 = change_tens_canon(TV)\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n      vâ‚‚ + vâ‚ƒ\n      vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚ + vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.components-Tuple{AbstractTens}","page":"Home","title":"TensND.components","text":"components(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim},var::NTuple{order,Symbol})\ncomponents(t::AbstractTens{order,dim,T},â„¬::AbstractBasis{dim})\ncomponents(t::AbstractTens{order,dim,T},var::NTuple{order,Symbol})\n\nExtracts the components of a tensor for new variances and/or in a new basis\n\nExamples\n\njulia> â„¬ = Basis(Sym[0 1 1; 1 0 1; 1 1 0]) ;\n\njulia> TV = Tens(Tensor{1,3}(i->symbols(\"v$i\",real=true)))\nTensND.TensCanonical{1, 3, Sym, Vec{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n vâ‚\n vâ‚‚\n vâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont,)\n\njulia> factor.(components(TV, â„¬, (:cont,)))\n3-element Vector{Sym}:\n -(v1 - v2 - v3)/2\n  (v1 - v2 + v3)/2\n  (v1 + v2 - v3)/2\n\njulia> components(TV, â„¬, (:cov,))\n3-element Vector{Sym}:\n vâ‚‚ + vâ‚ƒ\n vâ‚ + vâ‚ƒ\n vâ‚ + vâ‚‚\n\njulia> simplify.(components(TV, normalize(â„¬), (:cov,)))\n3-element Vector{Sym}:\n sqrt(2)*(v2 + v3)/2\n sqrt(2)*(v1 + v3)/2\n sqrt(2)*(v1 + v2)/2\n\njulia> TT = Tens(Tensor{2,3}((i,j)->symbols(\"t$i$j\",real=true)))\nTensND.TensCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3Ã—3 Tensor{2, 3, Sym, 9}:\n tâ‚â‚  tâ‚â‚‚  tâ‚â‚ƒ\n tâ‚‚â‚  tâ‚‚â‚‚  tâ‚‚â‚ƒ\n tâ‚ƒâ‚  tâ‚ƒâ‚‚  tâ‚ƒâ‚ƒ\n# basis: 3Ã—3 TensND.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n# var: (:cont, :cont)\n\njulia> components(TT, â„¬, (:cov,:cov))\n3Ã—3 Matrix{Sym}:\n tâ‚‚â‚‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚\n tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚‚â‚‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚‚â‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚‚â‚ + tâ‚‚â‚‚\n\njulia> factor.(components(TT, â„¬, (:cont,:cov)))\n3Ã—3 Matrix{Sym}:\n -(t12 + t13 - t22 - t23 - t32 - t33)/2  â€¦  -(t11 + t12 - t21 - t22 - t31 - t32)/2\n  (t12 + t13 - t22 - t23 + t32 + t33)/2      (t11 + t12 - t21 - t22 + t31 + t32)/2\n  (t12 + t13 + t22 + t23 - t32 - t33)/2      (t11 + t12 + t21 + t22 - t31 - t32)/2\n\n\n\n\n\n","category":"method"},{"location":"#TensND.components_canon-Tuple{AbstractTens}","page":"Home","title":"TensND.components_canon","text":"components_canon(t::AbstractTens)\n\nExtracts the components of a tensor in the canonical basis\n\n\n\n\n\n","category":"method"},{"location":"#TensND.contract-Union{Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, T} where T<:Number, Int64, Int64}} where {order, dim}","page":"Home","title":"TensND.contract","text":"contract(t::AbstractTens{order,dim}, i::Int, j::Int)\n\nCalculates the tensor obtained after contraction with respect to the indices i and j\n\n\n\n\n\n","category":"method"},{"location":"#TensND.init_cartesian","page":"Home","title":"TensND.init_cartesian","text":"init_cartesian(coords = symbols(\"x y z\", real = true))\n\nReturns the coordinates, unit vectors and basis of the cartesian basis\n\nExamples\n\njulia> coords, vectors, â„¬ = init_cartesian() ; x, y, z = coords ; ğâ‚, ğâ‚‚, ğâ‚ƒ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"#TensND.init_cylindrical","page":"Home","title":"TensND.init_cylindrical","text":"init_cylindrical(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true), symbols(\"z\", real = true)); canonical = false)\n\nReturns the coordinates, base vectors and basis of the cylindrical basis\n\nExamples\n\njulia> coords, vectors, â„¬á¶œ = init_cylindrical() ; r, Î¸, z = coords ; ğÊ³, ğá¶¿, ğá¶» = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"#TensND.init_polar","page":"Home","title":"TensND.init_polar","text":"init_polar(coords = (symbols(\"r\", positive = true), symbols(\"Î¸\", real = true)); canonical = false)\n\nReturns the coordinates, base vectors and basis of the polar basis\n\nExamples\n\njulia> coords, vectors, â„¬áµ– = init_polar() ; r, Î¸ = coords ; ğÊ³, ğá¶¿ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"#TensND.init_rotated","page":"Home","title":"TensND.init_rotated","text":"init_rotated(coords = symbols(\"Î¸ Ï• Ïˆ\", real = true); canonical = false)\n\nReturns the angles, base vectors and basis of the rotated basis. Note that here the coordinates are angles and do not represent a valid parametrization of â„Â³\n\nExamples\n\njulia> angles, vectors, â„¬Ê³ = init_rotated() ; Î¸, Ï•, Ïˆ = angles ; ğá¶¿, ğáµ , ğÊ³ = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"#TensND.init_spherical","page":"Home","title":"TensND.init_spherical","text":"init_spherical(coords = (symbols(\"Î¸\", real = true), symbols(\"Ï•\", real = true), symbols(\"r\", positive = true)); canonical = false)\n\nReturns the coordinates, base vectors and basis of the spherical basis. Take care that the order of the 3 vectors is ğá¶¿, ğáµ , ğÊ³ so that the basis coincides with the canonical one when the angles are null and in consistency the coordinates are ordered as Î¸, Ï•, r.\n\nExamples\n\njulia> coords, vectors, â„¬Ë¢ = init_spherical() ; Î¸, Ï•, r = coords ; ğá¶¿, ğáµ , ğÊ³  = vectors ;\n\n\n\n\n\n","category":"function"},{"location":"#TensND.invKM-Tuple{Type{var\"#s1\"} where var\"#s1\"<:(Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}), AbstractVecOrMat{T} where T}","page":"Home","title":"TensND.invKM","text":"invKM(v::AbstractVecOrMat; kwargs...)\n\nDefines a tensor from a Kelvin-Mandel vector or matrix representation\n\n\n\n\n\n","category":"method"},{"location":"#TensND.isorthogonal-Tuple{TensND.AbstractBasis}","page":"Home","title":"TensND.isorthogonal","text":"isorthogonal(â„¬::AbstractBasis)\n\nChecks whether the basis â„¬ is orthogonal\n\n\n\n\n\n","category":"method"},{"location":"#TensND.isorthonormal-Tuple{TensND.AbstractBasis}","page":"Home","title":"TensND.isorthonormal","text":"isorthonormal(â„¬::AbstractBasis)\n\nChecks whether the basis â„¬ is orthonormal\n\n\n\n\n\n","category":"method"},{"location":"#TensND.metric-Tuple{TensND.AbstractBasis, Val{:cov}}","page":"Home","title":"TensND.metric","text":"metric(â„¬::AbstractBasis, var = :cov)\n\nReturns the covariant (if var = :cov) or contravariant (if var = :cont) metric matrix\n\n\n\n\n\n","category":"method"},{"location":"#TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, order2, dim}","page":"Home","title":"TensND.otimesul","text":"otimesul(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefines a special tensor product between two tensors of at least second order\n\n(ğš âŠ Ë¢ ğ›) âŠ¡ ğ© = (ğš âŠ  ğ›) âŠ¡ (ğ© + áµ—ğ©)/2  = 1/2(aâ±áµbÊ²Ë¡+aâ±Ë¡bÊ²áµ) pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#TensND.qcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, order2, dim}","page":"Home","title":"TensND.qcontract","text":"dcontract(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefines a quadruple contracted product between two tensors\n\nğ”¸ âŠ™ ğ”¹ = Aáµ¢â±¼â‚–â‚—Bâ±Ê²áµË¡\n\nExamples\n\njulia> ğ•€ = tğ•€(Sym) ; ğ• = tğ•(Sym) ; ğ•‚ = tğ•‚(Sym) ;\n\njulia> ğ•€ âŠ™ ğ•€\n6\n\njulia> ğ• âŠ™ ğ•€\n1\n\njulia> ğ•‚ âŠ™ ğ•€\n5\n\njulia> ğ•‚ âŠ™ ğ•\n0\n\n\n\n\n\n","category":"method"},{"location":"#TensND.rot2-Tuple{Any}","page":"Home","title":"TensND.rot2","text":"rot2(Î¸)\n\nReturns a 2D rotation matrix with respect to the angle Î¸\n\nExamples\n\njulia> rot2(Î¸)\n2Ã—2 Tensor{2, 2, Sym, 4}:\n cos(Î¸)  -sin(Î¸)\n sin(Î¸)   cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.rot3","page":"Home","title":"TensND.rot3","text":"rot3(Î¸, Ï• = 0, Ïˆ = 0)\n\nReturns a rotation matrix with respect to the 3 Euler angles Î¸, Ï•, Ïˆ\n\nExamples\n\njulia> cÎ¸, cÏ•, cÏˆ, sÎ¸, sÏ•, sÏˆ = symbols(\"cÎ¸ cÏ• cÏˆ sÎ¸ sÏ• sÏˆ\", real = true) ;\n\njulia> d = Dict(cos(Î¸) => cÎ¸, cos(Ï•) => cÏ•, cos(Ïˆ) => cÏˆ, sin(Î¸) => sÎ¸, sin(Ï•) => sÏ•, sin(Ïˆ) => sÏˆ) ;\n\njulia> subs.(rot3(Î¸, Ï•, Ïˆ),d...)\n3Ã—3 StaticArrays.SMatrix{3, 3, Sym, 9} with indices SOneTo(3)Ã—SOneTo(3):\n cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•  -cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•  cÏ•â‹…sÎ¸\n cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ  -cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•  sÎ¸â‹…sÏ•\n           -cÏˆâ‹…sÎ¸              sÎ¸â‹…sÏˆ     cÎ¸\n\n\n\n\n\n","category":"function"},{"location":"#TensND.rot6","page":"Home","title":"TensND.rot6","text":"rot6(Î¸, Ï• = 0, Ïˆ = 0)\n\nReturns a rotation matrix with respect to the 3 Euler angles Î¸, Ï•, Ïˆ\n\nExamples\n\njulia> cÎ¸, cÏ•, cÏˆ, sÎ¸, sÏ•, sÏˆ = symbols(\"cÎ¸ cÏ• cÏˆ sÎ¸ sÏ• sÏˆ\", real = true) ;\n\njulia> d = Dict(cos(Î¸) => cÎ¸, cos(Ï•) => cÏ•, cos(Ïˆ) => cÏˆ, sin(Î¸) => sÎ¸, sin(Ï•) => sÏ•, sin(Ïˆ) => sÏˆ) ;\n\njulia> R = Tens(subs.(rot3(Î¸, Ï•, Ïˆ),d...))\nTens.TensCanonical{2, 3, Sym, Tensor{2, 3, Sym, 9}}\n# data: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•  -cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•  cÏ•â‹…sÎ¸\n cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ  -cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•  sÎ¸â‹…sÏ•\n           -cÏˆâ‹…sÎ¸              sÎ¸â‹…sÏˆ     cÎ¸\n# var: (:cont, :cont)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> RR = R âŠ Ë¢ R\nTens.TensCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6Ã—6 Matrix{Sym}:\n                          (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)^2                            (-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)^2           cÏ•^2*sÎ¸^2                      âˆš2â‹…cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)                     âˆš2â‹…cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)\n                          (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)^2                            (-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•)^2           sÎ¸^2*sÏ•^2                      âˆš2â‹…sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)                     âˆš2â‹…sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)\n                                     cÏˆ^2*sÎ¸^2                                        sÎ¸^2*sÏˆ^2                cÎ¸^2                                       âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏˆ                                    -âˆš2â‹…cÎ¸â‹…cÏˆâ‹…sÎ¸                                                              -sqrt(2)*cÏˆ*sÎ¸^2*sÏˆ\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)    âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏ•                    cÎ¸*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + sÎ¸^2*sÏˆ*sÏ•                   cÎ¸*(cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ) - cÏˆ*sÎ¸^2*sÏ•                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)    âˆš2â‹…cÎ¸â‹…cÏ•â‹…sÎ¸                    cÎ¸*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•) + cÏ•*sÎ¸^2*sÏˆ                   cÎ¸*(cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•) - cÏˆ*cÏ•*sÎ¸^2                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)\n âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)  âˆš2â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)  sqrt(2)*cÏ•*sÎ¸^2*sÏ•  cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)  cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ) + sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)  (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 = invKM(subs.(KM(rot6(Î¸, Ï•, Ïˆ)),d...))\nTens.TensCanonical{4, 3, Sym, SymmetricTensor{4, 3, Sym, 36}}\n# data: 6Ã—6 Matrix{Sym}:\n                          (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)^2                            (-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)^2           cÏ•^2*sÎ¸^2                      âˆš2â‹…cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)                     âˆš2â‹…cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)\n                          (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)^2                            (-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•)^2           sÎ¸^2*sÏ•^2                      âˆš2â‹…sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)                     âˆš2â‹…sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                                   âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)\n                                     cÏˆ^2*sÎ¸^2                                        sÎ¸^2*sÏˆ^2                cÎ¸^2                                       âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏˆ                                    -âˆš2â‹…cÎ¸â‹…cÏˆâ‹…sÎ¸                                                              -sqrt(2)*cÏˆ*sÎ¸^2*sÏˆ\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)    âˆš2â‹…cÎ¸â‹…sÎ¸â‹…sÏ•                    cÎ¸*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + sÎ¸^2*sÏˆ*sÏ•                   cÎ¸*(cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ) - cÏˆ*sÎ¸^2*sÏ•                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)\n             -âˆš2â‹…cÏˆâ‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)                âˆš2â‹…sÎ¸â‹…sÏˆâ‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)    âˆš2â‹…cÎ¸â‹…cÏ•â‹…sÎ¸                    cÎ¸*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•) + cÏ•*sÎ¸^2*sÏˆ                   cÎ¸*(cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•) - cÏˆ*cÏ•*sÎ¸^2                            -cÏˆâ‹…sÎ¸â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•) + sÎ¸â‹…sÏˆâ‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)\n âˆš2â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ)  âˆš2â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•)  sqrt(2)*cde Liv Lehn Ï•*sÎ¸^2*sÏ•  cÏ•â‹…sÎ¸â‹…(-cÎ¸â‹…sÏˆâ‹…sÏ• + cÏˆâ‹…cÏ•) + sÎ¸â‹…sÏ•â‹…(-cÎ¸â‹…cÏ•â‹…sÏˆ - cÏˆâ‹…sÏ•)  cÏ•â‹…sÎ¸â‹…(cÎ¸â‹…cÏˆâ‹…sÏ• + cÏ•â‹…sÏˆ) + sÎ¸â‹…sÏ•â‹…(cÎ¸â‹…cÏˆâ‹…cÏ• - sÏˆâ‹…sÏ•)  (cÎ¸*cÏˆ*cÏ• - sÏˆ*sÏ•)*(-cÎ¸*sÏˆ*sÏ• + cÏˆ*cÏ•) + (cÎ¸*cÏˆ*sÏ• + cÏ•*sÏˆ)*(-cÎ¸*cÏ•*sÏˆ - cÏˆ*sÏ•)\n# var: (:cont, :cont, :cont, :cont)\n# basis: 3Ã—3 Tens.LazyIdentity{3, Sym}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> R6 == RR\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, order2, dim}","page":"Home","title":"TensND.sotimes","text":"sotimes(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefines a symmetric tensor product between two tensors\n\n(aâ±eáµ¢) âŠ—Ë¢ (bÊ²eâ±¼) = 1/2(aâ±bÊ² + aÊ²bâ±) eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#TensND.tensId2-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"Home","title":"TensND.tensId2","text":"tensId2(::Val{dim}, ::Val{T}) where {dim,T<:Number}\ntğŸ(::Val{dim}, ::Val{T}) where {dim,T<:Number}\n\nIdentity tensor of second order ğŸáµ¢â±¼ = Î´áµ¢â±¼ = 1 if i=j otherwise 0\n\nExamples\n\njulia> ğŸ = tğŸ() ; KM(ğŸ)\n6-element Vector{Sym}:\n 1\n 1\n 1\n 0\n 0\n 0\n\njulia> ğŸ.data\n3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#TensND.tensId4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"Home","title":"TensND.tensId4","text":"tensId4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\ntğ•€(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nSymmetric identity tensor of fourth order  ğ•€ = ğŸ âŠ Ë¢ ğŸ i.e. (ğ•€)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2\n\nExamples\n\njulia> ğ•€ = tğ•€() ; KM(ğ•€)\n6Ã—6 Matrix{Sym}:\n 1  0  0  0  0  0\n 0  1  0  0  0  0\n 0  0  1  0  0  0\n 0  0  0  1  0  0\n 0  0  0  0  1  0\n 0  0  0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#TensND.tensJ4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"Home","title":"TensND.tensJ4","text":"tensJ4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\ntğ•(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nSpherical projector of fourth order  ğ• = (ğŸ âŠ— ğŸ) / dim i.e. (ğ•)áµ¢â±¼â‚–â‚— = Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ• = tğ•() ; KM(ğ•)\n6Ã—6 Matrix{Sym}:\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n 1/3  1/3  1/3  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n   0    0    0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"#TensND.tensK4-Union{Tuple{}, Tuple{Val{dim}}, Tuple{T}, Tuple{dim}, Tuple{Val{dim}, Val{T}}} where {dim, T<:Number}","page":"Home","title":"TensND.tensK4","text":"tensK4(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\ntğ•‚(::Val{dim} = Val(3), ::Val{T} = Val(Sym))\n\nDeviatoric projector of fourth order  ğ•‚ = ğ•€ - ğ• i.e. (ğ•‚)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2 - Î´áµ¢â±¼Î´â‚–â‚—/dim\n\nExamples\n\njulia> ğ•‚ = tğ•‚() ; KM(ğ•‚)\n6Ã—6 Matrix{Sym}:\n  2/3  -1/3  -1/3  0  0  0\n -1/3   2/3  -1/3  0  0  0\n -1/3  -1/3   2/3  0  0  0\n    0     0     0  1  0  0\n    0     0     0  0  1  0\n    0     0     0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#TensND.vecbasis-Tuple{TensND.AbstractBasis, Val{:cov}}","page":"Home","title":"TensND.vecbasis","text":"vecbasis(â„¬::AbstractBasis, var = :cov)\n\nReturns the primal (if var = :cov) or dual (if var = :cont) basis\n\n\n\n\n\n","category":"method"},{"location":"#TensND.âˆ‚-Union{Tuple{dim}, Tuple{order}, Tuple{AbstractTens{order, dim, Sym}, Vararg{Any, N} where N}} where {order, dim}","page":"Home","title":"TensND.âˆ‚","text":"âˆ‚(t::AbstractTens{order,dim,Sym,A},xáµ¢::Sym)\n\nReturns the derivative of the tensor t with respect to the variable x_i\n\nExamples\n\n\njulia> Î¸, Ï•, â„¬Ë¢, ğá¶¿, ğáµ , ğÊ³ = init_spherical(symbols(\"Î¸ Ï•\", real = true)...) ;\n\njulia> âˆ‚(ğÊ³, Ï•) == sin(Î¸) * ğáµ \ntrue\n\njulia> âˆ‚(ğÊ³ âŠ— ğÊ³,Î¸)\nTens.TensRotated{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n 0  0  1\n 0  0  0\n 1  0  0\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)â‹…cos(Ï•)  -sin(Ï•)  sin(Î¸)â‹…cos(Ï•)\n sin(Ï•)â‹…cos(Î¸)   cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n       -sin(Î¸)        0         cos(Î¸)\n# var: (:cont, :cont)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğ-Union{Tuple{Val{i}}, Tuple{T}, Tuple{dim}, Tuple{i}, Tuple{Val{i}, Val{dim}}, Tuple{Val{i}, Val{dim}, Val{T}}} where {i, dim, T<:Number}","page":"Home","title":"TensND.ğ","text":"ğ(i::Int, dim::Int = 3, T::Type{<:Number} = Sym)\n\nVector of the canonical basis\n\nExamples\n\njulia> ğ(1)\nTens{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğË¢-Union{Tuple{Val{1}}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Val{1}, T1}, Tuple{Val{1}, T1, T2}, Tuple{Val{1}, T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Home","title":"TensND.ğË¢","text":"ğË¢(i::Int, Î¸::T = zero(Sym), Ï•::T = zero(Sym), Ïˆ::T = zero(Sym); canonical = false)\n\nVector of the basis rotated with the 3 Euler angles Î¸, Ï•, Ïˆ (spherical if Ïˆ=0)\n\nExamples\n\njulia> Î¸, Ï•, Ïˆ = symbols(\"Î¸, Ï•, Ïˆ\", real = true) ;\n\nTens{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)\n  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)\n                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğáµ–-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"Home","title":"TensND.ğáµ–","text":"ğáµ–(i::Int, Î¸::T = zero(Sym); canonical = false)\n\nVector of the polar basis\n\nExamples\n\njulia> Î¸ = symbols(\"Î¸\", real = true) ;\n\njulia> ğáµ–(1, Î¸)\nTens{1, 2, Sym, Sym, Vec{2, Sym}, RotatedBasis{2, Sym}}\n# data: 2-element Vec{2, Sym}:\n 1\n 0\n# var: (:cont,)\n# basis: 2Ã—2 Tensor{2, 2, Sym, 4}:\n cos(Î¸)  -sin(Î¸)\n sin(Î¸)   cos(Î¸)\n\n\n\n\n\n","category":"method"},{"location":"#TensND.ğá¶œ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T<:Number","page":"Home","title":"TensND.ğá¶œ","text":"ğá¶œ(i::Int, Î¸::T = zero(Sym); canonical = false)\n\nVector of the cylindrical basis\n\nExamples\n\njulia> Î¸ = symbols(\"Î¸\", real = true) ;\n\njulia> ğá¶œ(1, Î¸)\nTens{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}\n# data: 3-element Vec{3, Sym}:\n 1\n 0\n 0\n# var: (:cont,)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n cos(Î¸)  -sin(Î¸)  0\n sin(Î¸)   cos(Î¸)  0\n      0        0  1\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, order2, dim}","page":"Home","title":"Tensors.dcontract","text":"dcontract(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefines a double contracted product between two tensors\n\nğ›” âŠ¡ ğ›† = Ïƒâ±Ê²Îµáµ¢â±¼ ğ›” = â„‚ âŠ¡ ğ›†\n\nExamples\n\njulia> ğ›† = Tens(SymmetricTensor{2,3}((i, j) -> symbols(\"Îµ$i$j\", real = true))) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> ğ›” = â„‚ âŠ¡ ğ›†\nTens{2, 3, Sym, Sym, SymmetricTensor{2, 3, Sym, 6}, CanonicalBasis{3, Sym}}\n# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:\n Îµ11*(k + 4*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ21â‹…Î¼                                              2â‹…Îµ31â‹…Î¼\n                                             2â‹…Îµ21â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k + 4*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ32â‹…Î¼\n                                             2â‹…Îµ31â‹…Î¼                                              2â‹…Îµ32â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k + 4*Î¼/3)\n# var: (:cont, :cont)\n# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{orderS, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, orderS, order2, dim}","page":"Home","title":"Tensors.dotdot","text":"dotdot(v1::AbstractTens{order1,dim}, S::AbstractTens{orderS,dim}, v2::AbstractTens{order2,dim})\n\nDefines a bilinear operator ğ¯â‚â‹…ğ•Šâ‹…ğ¯â‚‚\n\nExamples\n\njulia> n = Tens(Sym[0, 0, 1]) ;\n\njulia> k, Î¼ = symbols(\"k Î¼\", real =true) ;\n\njulia> â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;\n\njulia> dotdot(n,â„‚,n) # Acoustic tensor\n3Ã—3 Tens{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}:\n Î¼  0          0\n 0  Î¼          0\n 0  0  k + 4*Î¼/3\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, order2, dim}","page":"Home","title":"Tensors.otimes","text":"otimes(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefines a tensor product between two tensors\n\n(aâ±eáµ¢) âŠ— (bÊ²eâ±¼) = aâ±bÊ² eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"},{"location":"#Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{AbstractTens{order1, dim, T} where T<:Number, AbstractTens{order2, dim, T} where T<:Number}} where {order1, order2, dim}","page":"Home","title":"Tensors.otimesu","text":"otimesu(t1::AbstractTens{order1,dim}, t2::AbstractTens{order2,dim})\n\nDefines a special tensor product between two tensors of at least second order\n\n(ğš âŠ  ğ›) âŠ¡ ğ© = ğšâ‹…ğ©â‹…ğ› = aâ±áµbÊ²Ë¡pâ‚–â‚— eáµ¢âŠ—eâ±¼\n\n\n\n\n\n","category":"method"}]
}
