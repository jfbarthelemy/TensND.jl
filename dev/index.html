<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home Â· TensND.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://jfbarthelemy.github.io/TensND.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TensND.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jfbarthelemy/TensND.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TensND"><a class="docs-heading-anchor" href="#TensND">TensND</a><a id="TensND-1"></a><a class="docs-heading-anchor-permalink" href="#TensND" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jfbarthelemy/TensND.jl">TensND</a>.</p><ul><li><a href="#TensND.Basis"><code>TensND.Basis</code></a></li><li><a href="#TensND.CanonicalBasis"><code>TensND.CanonicalBasis</code></a></li><li><a href="#TensND.RotatedBasis"><code>TensND.RotatedBasis</code></a></li><li><a href="#TensND.Tensnd"><code>TensND.Tensnd</code></a></li><li><a href="#LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>LinearAlgebra.dot</code></a></li><li><a href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a></li><li><a href="#TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}}"><code>TensND.KM</code></a></li><li><a href="#TensND.LeviCivita"><code>TensND.LeviCivita</code></a></li><li><a href="#TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>TensND.angles</code></a></li><li><a href="#TensND.components-Tuple{TensND.AbstractTensnd}"><code>TensND.components</code></a></li><li><a href="#TensND.init_canonical"><code>TensND.init_canonical</code></a></li><li><a href="#TensND.init_cylindrical-Tuple{Any}"><code>TensND.init_cylindrical</code></a></li><li><a href="#TensND.init_isotropic"><code>TensND.init_isotropic</code></a></li><li><a href="#TensND.init_polar-Tuple{Any}"><code>TensND.init_polar</code></a></li><li><a href="#TensND.init_rotated-Tuple{Any, Any, Any}"><code>TensND.init_rotated</code></a></li><li><a href="#TensND.init_spherical-Tuple{Any, Any}"><code>TensND.init_spherical</code></a></li><li><a href="#TensND.invKM-Tuple{Type{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:(Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}), AbstractVecOrMat{T} where T}"><code>TensND.invKM</code></a></li><li><a href="#TensND.isorthogonal-Tuple{AbstractBasis}"><code>TensND.isorthogonal</code></a></li><li><a href="#TensND.isorthonormal-Tuple{AbstractBasis}"><code>TensND.isorthonormal</code></a></li><li><a href="#TensND.metric-Tuple{AbstractBasis, Val{:cov}}"><code>TensND.metric</code></a></li><li><a href="#TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>TensND.otimesul</code></a></li><li><a href="#TensND.qcontract-Union{Tuple{order2}, Tuple{order1}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, order1}, AbstractArray{T2, order2}}} where {T1, T2, order1, order2}"><code>TensND.qcontract</code></a></li><li><a href="#TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>TensND.sotimes</code></a></li><li><a href="#TensND.tensId2"><code>TensND.tensId2</code></a></li><li><a href="#TensND.tensId4"><code>TensND.tensId4</code></a></li><li><a href="#TensND.tensId4s"><code>TensND.tensId4s</code></a></li><li><a href="#TensND.tensJ4"><code>TensND.tensJ4</code></a></li><li><a href="#TensND.tensK4"><code>TensND.tensK4</code></a></li><li><a href="#TensND.vecbasis-Tuple{AbstractBasis, Val{:cov}}"><code>TensND.vecbasis</code></a></li><li><a href="#TensND.ğ"><code>TensND.ğ</code></a></li><li><a href="#TensND.ğË¢-Union{Tuple{Val{1}}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Val{1}, T1}, Tuple{Val{1}, T1, T2}, Tuple{Val{1}, T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>TensND.ğË¢</code></a></li><li><a href="#TensND.ğáµ–-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T&lt;:Number"><code>TensND.ğáµ–</code></a></li><li><a href="#TensND.ğá¶œ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T&lt;:Number"><code>TensND.ğá¶œ</code></a></li><li><a href="#Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>Tensors.dcontract</code></a></li><li><a href="#Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{orderS, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, orderS, order2, dim}"><code>Tensors.dotdot</code></a></li><li><a href="#Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>Tensors.otimes</code></a></li><li><a href="#Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>Tensors.otimesu</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TensND.Basis" href="#TensND.Basis"><code>TensND.Basis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Basis(v::AbstractArray{T,2}, ::Val{:cov})
Basis{dim, T&lt;:Number}()
Basis(Î¸::T&lt;:Number, Ï•::T&lt;:Number, Ïˆ::T&lt;:Number)</code></pre><p>Basis built from a square matrix <code>v</code> where columns correspond either to</p><ul><li>primal vectors ie <code>eáµ¢=v[:,i]</code> if <code>var=:cov</code> as by default</li><li>dual vectors ie <code>eâ±=v[:,i]</code> if <code>var=:cont</code>.</li></ul><p>Basis without any argument refers to the canonical basis (<code>CanonicalBasis</code>) in <code>Ráµˆâ±áµ</code> (by default <code>dim=3</code> and <code>T=Sym</code>)</p><p>Basis can also be built from Euler angles (<code>RotatedBasis</code>) <code>Î¸</code> in 2D and <code>(Î¸, Ï•, Ïˆ)</code> in 3D</p><p>The attributes of this object are</p><ul><li><code>Basis.e</code>: square matrix defining the primal basis <code>eáµ¢=e[:,i]</code></li><li><code>Basis.E</code>: square matrix defining the dual basis <code>eâ±=E[:,i]</code></li><li><code>Basis.g</code>: square matrix defining the covariant components of the metric tensor <code>gáµ¢â±¼=eáµ¢â‹…eâ±¼=g[i,j]</code></li><li><code>Basis.G</code>: square matrix defining the contravariant components of the metric tensor <code>gâ±Ê²=eâ±â‹…eÊ²=G[i,j]</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; v = Sym[1 0 0; 0 1 0; 0 1 1] ; b = Basis(v)
Basis{3, Sym}
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 1  0  0
 0  1  0
 0  1  1
# dual basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 1  0   0
 0  1  -1
 0  0   1
# covariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:
 1  0  0
 0  2  1
 0  1  1
# contravariant metric tensor: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:
 1   0   0
 0   1  -1
 0  -1   2</code></pre><pre><code class="language-julia hljs">julia&gt; Î¸, Ï•, Ïˆ = symbols(&quot;Î¸, Ï•, Ïˆ&quot;, real = true) ; b = Basis(Î¸, Ï•, Ïˆ) ; display(b.e)
3Ã—3 Tensor{2, 3, Sym, 9}:
 -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)
  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)
                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L16-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.CanonicalBasis" href="#TensND.CanonicalBasis"><code>TensND.CanonicalBasis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CanonicalBasis{dim, T}</code></pre><p>Canonical basis of dimension <code>dim</code> (default: 3) and type <code>T</code> (default: Sym)</p><p>The attributes of this object are</p><ul><li><code>Basis.e</code>: identity matrix defining the primal basis <code>e[i,j]=Î´áµ¢â±¼</code></li><li><code>Basis.E</code>: identity matrix defining the dual basis <code>g[i,j]=Î´áµ¢â±¼</code></li><li><code>Basis.g</code>: identity matrix defining the covariant components of the metric tensor <code>g[i,j]=Î´áµ¢â±¼</code></li><li><code>Basis.G</code>: identity matrix defining the contravariant components of the metric tensor <code>G[i,j]=Î´áµ¢â±¼</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; b = CanonicalBasis()
CanonicalBasis{3, SymPy.Sym}
# basis: 3Ã—3 Tensors.Tensor{2, 3, SymPy.Sym, 9}:
 1  0  0
 0  1  0
 0  0  1
# dual basis: 3Ã—3 Tensors.Tensor{2, 3, SymPy.Sym, 9}:
 1  0  0
 0  1  0
 0  0  1
# covariant metric tensor: 3Ã—3 Tensors.SymmetricTensor{2, 3, SymPy.Sym, 6}:
 1  0  0
 0  1  0
 0  0  1
# contravariant metric tensor: 3Ã—3 Tensors.SymmetricTensor{2, 3, SymPy.Sym, 6}:
 1  0  0
 0  1  0
 0  0  1

julia&gt; b = CanonicalBasis{2, Float64}()
CanonicalBasis{2, Float64}
# basis: 2Ã—2 Tensors.Tensor{2, 2, Float64, 4}:
 1.0  0.0
 0.0  1.0
# dual basis: 2Ã—2 Tensors.Tensor{2, 2, Float64, 4}:
 1.0  0.0
 0.0  1.0
# covariant metric tensor: 2Ã—2 Tensors.SymmetricTensor{2, 2, Float64, 3}:
 1.0  0.0
 0.0  1.0
# contravariant metric tensor: 2Ã—2 Tensors.SymmetricTensor{2, 2, Float64, 3}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L134-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.RotatedBasis" href="#TensND.RotatedBasis"><code>TensND.RotatedBasis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RotatedBasis(Î¸::T&lt;:Number, Ï•::T&lt;:Number, Ïˆ::T&lt;:Number)
RotatedBasis(Î¸::T&lt;:Number)</code></pre><p>Orthonormal basis of dimension <code>dim</code> (default: 3) and type <code>T</code> (default: Sym) built from Euler angles <code>Î¸</code> in 2D and <code>(Î¸, Ï•, Ïˆ)</code> in 3D</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸, Ï•, Ïˆ = symbols(&quot;Î¸, Ï•, Ïˆ&quot;, real = true) ; b = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(b.e)
3Ã—3 Tensor{2, 3, Sym, 9}:
 -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)
  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)
                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L185-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.Tensnd" href="#TensND.Tensnd"><code>TensND.Tensnd</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tensnd{order,dim,T,A&lt;:AbstractArray,B&lt;:AbstractBasis}</code></pre><p>Tensor type of any order defined by</p><ul><li>a multiarray of components (of any type heriting from <code>AbstractArray</code>, e.g. <code>Tensor</code> or <code>SymmetricTensor</code>)</li><li>a basis of <code>AbstractBasis</code> type</li><li>a tuple of variances (covariant <code>:cov</code> or contravariant <code>:cont</code>) of length equal to the <code>order</code> of the tensor</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; v = Sym[1 0 0; 0 1 0; 0 1 1] ; b = Basis(v) ;

julia&gt; T = Tensnd(b.g,(:cov,:cov),b)
Tensnd{2, 3, Sym, SymmetricTensor{2, 3, Sym, 6}, Basis{3, Sym}}
# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:
 1  0  0
 0  2  1
 0  1  1
# var: (:cov, :cov)
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 1  0  0
 0  1  0
 0  1  1

julia&gt; components(T,(:cont,:cov),b)
3Ã—3 Matrix{Sym}:
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L14-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}" href="#LinearAlgebra.dot-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>LinearAlgebra.dot</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})</code></pre><p>Defines a contracted product between two tensors</p><p><code>a â‹… b = aâ±bâ±¼</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L516-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize(b::AbstractBasis, var = cov)</code></pre><p>Builds a basis after normalization of column vectors of input matrix <code>v</code> where columns define either</p><ul><li>primal vectors ie <code>eáµ¢=v[:,i]/norm(v[:,i])</code> if <code>var = :cov</code> as by default</li><li>dual vector ie <code>eâ±=v[:,i]/norm(v[:,i])</code> if <code>var = :cont</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L294-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}}" href="#TensND.KM-Tuple{Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}}"><code>TensND.KM</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KM(t::AbstractTensnd{order,dim}; kwargs...)
KM(t::AbstractTensnd{order,dim}, var::NTuple{order,Symbol}, b::AbstractBasis{dim}; kwargs...)</code></pre><p>Writes the components of a second or fourth order tensor in Kelvin-Mandel notation</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Ïƒ = Tensnd(SymmetricTensor{2,3}((i, j) -&gt; symbols(&quot;Ïƒ$i$j&quot;, real = true))) ;

julia&gt; KM(Ïƒ)
6-element Vector{Sym}:
         Ïƒ11
         Ïƒ22
         Ïƒ33
      âˆš2â‹…Ïƒ32
      âˆš2â‹…Ïƒ31
      âˆš2â‹…Ïƒ21

julia&gt; C = Tensnd(SymmetricTensor{4,3}((i, j, k, l) -&gt; symbols(&quot;C$i$j$k$l&quot;, real = true))) ;

julia&gt; KM(C)
6Ã—6 Matrix{Sym}:
         Câ‚â‚â‚â‚     Câ‚â‚â‚‚â‚‚     Câ‚â‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚â‚â‚ƒâ‚‚  âˆš2â‹…Câ‚â‚â‚ƒâ‚  âˆš2â‹…Câ‚â‚â‚‚â‚
         Câ‚‚â‚‚â‚â‚     Câ‚‚â‚‚â‚‚â‚‚     Câ‚‚â‚‚â‚ƒâ‚ƒ  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚‚  âˆš2â‹…Câ‚‚â‚‚â‚ƒâ‚  âˆš2â‹…Câ‚‚â‚‚â‚‚â‚
         Câ‚ƒâ‚ƒâ‚â‚     Câ‚ƒâ‚ƒâ‚‚â‚‚     Câ‚ƒâ‚ƒâ‚ƒâ‚ƒ  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚ƒâ‚  âˆš2â‹…Câ‚ƒâ‚ƒâ‚‚â‚
      âˆš2â‹…Câ‚ƒâ‚‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚‚â‚‚â‚
      âˆš2â‹…Câ‚ƒâ‚â‚â‚  âˆš2â‹…Câ‚ƒâ‚â‚‚â‚‚  âˆš2â‹…Câ‚ƒâ‚â‚ƒâ‚ƒ   2â‹…Câ‚ƒâ‚â‚ƒâ‚‚   2â‹…Câ‚ƒâ‚â‚ƒâ‚   2â‹…Câ‚ƒâ‚â‚‚â‚
      âˆš2â‹…Câ‚‚â‚â‚â‚  âˆš2â‹…Câ‚‚â‚â‚‚â‚‚  âˆš2â‹…Câ‚‚â‚â‚ƒâ‚ƒ   2â‹…Câ‚‚â‚â‚ƒâ‚‚   2â‹…Câ‚‚â‚â‚ƒâ‚   2â‹…Câ‚‚â‚â‚‚â‚</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L394-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.LeviCivita" href="#TensND.LeviCivita"><code>TensND.LeviCivita</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LeviCivita(T::Type{&lt;:Number} = Sym)</code></pre><p>Builds an Array{T,3} of Levi-Civita Symbol <code>Ïµáµ¢â±¼â‚– = (i-j) (j-k) (k-i) / 2</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Îµ = LeviCivita(Sym)
3Ã—3Ã—3 Array{Sym, 3}:
[:, :, 1] =
 0   0  0
 0   0  1
 0  -1  0

[:, :, 2] =
 0  0  -1
 0  0   0
 1  0   0

[:, :, 3] =
  0  1  0
 -1  0  0
  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#TensND.angles-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>TensND.angles</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles(M::AbstractArray{T,2})</code></pre><p>Determines the Euler angles corresponding to the input matrix supposed to be a rotation matrix or at least a similarity</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸, Ï•, Ïˆ = symbols(&quot;Î¸, Ï•, Ïˆ&quot;, real = true) ; b = RotatedBasis(Î¸, Ï•, Ïˆ) ; display(b.e)
3Ã—3 Tensor{2, 3, Sym, 9}:
 -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)
  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)
                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)

julia&gt; angles(b)
(Î¸ = Î¸, Ï• = Ï•, Ïˆ = Ïˆ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L234-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.components-Tuple{TensND.AbstractTensnd}" href="#TensND.components-Tuple{TensND.AbstractTensnd}"><code>TensND.components</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">components(::Tensnd{order,dim,T}, ::NTuple{order,Symbol})
components(::Tensnd{order,dim,T}, ::NTuple{order,Symbol}, ::AbstractBasis{dim,T})
components(::Tensnd{order,dim,T}, ::AbstractBasis{dim,T})</code></pre><p>Extracts the components of a tensor for new variances and/or in a new basis</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; v = Sym[0 1 1; 1 0 1; 1 1 0] ; b = Basis(v) ;

julia&gt; V = Tensor{1,3}(i-&gt;symbols(&quot;v$i&quot;,real=true))
3-element Vec{3, Sym}:
 vâ‚
 vâ‚‚
 vâ‚ƒ

julia&gt; TV = Tensnd(V) # TV = Tensnd(V, (:cont,), CanonicalBasis())
Tensnd{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}
# data: 3-element Vec{3, Sym}:
 vâ‚
 vâ‚‚
 vâ‚ƒ
# var: (:cont,)
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 1  0  0
 0  1  0
 0  0  1

julia&gt; factor.(components(TV, (:cont,), b))
3-element Vector{Sym}:
 -(v1 - v2 - v3)/2
  (v1 - v2 + v3)/2
  (v1 + v2 - v3)/2

julia&gt; components(TV, (:cov,), b)
3-element Vector{Sym}:
 vâ‚‚ + vâ‚ƒ
 vâ‚ + vâ‚ƒ
 vâ‚ + vâ‚‚

julia&gt; simplify.(components(TV, (:cov,), normal_basis(b)))
3-element Vector{Sym}:
 sqrt(2)*(v2 + v3)/2
 sqrt(2)*(v1 + v3)/2
 sqrt(2)*(v1 + v2)/2

julia&gt; T = Tensor{2,3}((i,j)-&gt;symbols(&quot;t$i$j&quot;,real=true))
3Ã—3 Tensor{2, 3, Sym, 9}:
 tâ‚â‚  tâ‚â‚‚  tâ‚â‚ƒ
 tâ‚‚â‚  tâ‚‚â‚‚  tâ‚‚â‚ƒ
 tâ‚ƒâ‚  tâ‚ƒâ‚‚  tâ‚ƒâ‚ƒ

julia&gt; TT = Tensnd(T)
Tensnd{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}
# data: 3Ã—3 Tensor{2, 3, Sym, 9}:
 tâ‚â‚  tâ‚â‚‚  tâ‚â‚ƒ
 tâ‚‚â‚  tâ‚‚â‚‚  tâ‚‚â‚ƒ
 tâ‚ƒâ‚  tâ‚ƒâ‚‚  tâ‚ƒâ‚ƒ
# var: (:cont, :cont)
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 1  0  0
 0  1  0
 0  0  1

julia&gt; components(TT, (:cov,:cov), b)
3Ã—3 Matrix{Sym}:
 tâ‚‚â‚‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚‚â‚ + tâ‚‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚
 tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚ƒâ‚‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚ƒâ‚ + tâ‚ƒâ‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚ƒâ‚ + tâ‚ƒâ‚‚
 tâ‚â‚‚ + tâ‚â‚ƒ + tâ‚‚â‚‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚ƒ + tâ‚‚â‚ + tâ‚‚â‚ƒ  tâ‚â‚ + tâ‚â‚‚ + tâ‚‚â‚ + tâ‚‚â‚‚

julia&gt; factor.(components(TT, (:cont,:cov), b))
3Ã—3 Matrix{Sym}:
 -(t12 + t13 - t22 - t23 - t32 - t33)/2  â€¦  -(t11 + t12 - t21 - t22 - t31 - t32)/2
  (t12 + t13 - t22 - t23 + t32 + t33)/2      (t11 + t12 - t21 - t22 + t31 + t32)/2
  (t12 + t13 + t22 + t23 - t32 - t33)/2      (t11 + t12 + t21 + t22 - t31 - t32)/2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L142-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.init_canonical" href="#TensND.init_canonical"><code>TensND.init_canonical</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_canonical(T::Type{&lt;:Number} = Sym)</code></pre><p>Returns the canonical basis and the 3 unit vectors</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; â„¬, ğâ‚, ğâ‚‚, ğâ‚ƒ = init_canonical()
(Sym[1 0 0; 0 1 0; 0 0 1], Sym[1, 0, 0], Sym[0, 1, 0], Sym[0, 0, 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L316-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.init_cylindrical-Tuple{Any}" href="#TensND.init_cylindrical-Tuple{Any}"><code>TensND.init_cylindrical</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_cylindrical(Î¸ ; canonical = false)</code></pre><p>Returns the angle, the cylindrical basis and the 3 unit vectors</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸, â„¬á¶œ, ğÊ³, ğá¶¿, ğá¶» = init_cylindrical(symbols(&quot;Î¸&quot;, real = true)) ;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L354-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.init_isotropic" href="#TensND.init_isotropic"><code>TensND.init_isotropic</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_isotropic(T::Type{&lt;:Number} = Sym)</code></pre><p>Returns the isotropic tensors</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğŸ, ğŸ™, ğ•€, ğ•, ğ•‚ = init_isotropic() ;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L329-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.init_polar-Tuple{Any}" href="#TensND.init_polar-Tuple{Any}"><code>TensND.init_polar</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_polar(Î¸ ; canonical = false)</code></pre><p>Returns the angle, the polar basis and the 2 unit vectors</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸, â„¬áµ–, ğÊ³, ğá¶¿ = init_polar(symbols(&quot;Î¸&quot;, real = true)) ;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L341-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.init_rotated-Tuple{Any, Any, Any}" href="#TensND.init_rotated-Tuple{Any, Any, Any}"><code>TensND.init_rotated</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_rotated(Î¸, Ï•, Ïˆ; canonical = false)</code></pre><p>Returns the angles, the ratated basis and the 3 unit vectors</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸, Ï•, Ïˆ, â„¬Ê³, ğá¶¿, ğáµ , ğÊ³ = init_rotated(symbols(&quot;Î¸ Ï• Ïˆ&quot;, real = true)...) ;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L390-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.init_spherical-Tuple{Any, Any}" href="#TensND.init_spherical-Tuple{Any, Any}"><code>TensND.init_spherical</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_spherical(Î¸, Ï•; canonical = false)</code></pre><p>Returns the angles, the spherical basis and the 3 unit vectors. Take care that the order of the 3 vectors is ğá¶¿, ğáµ , ğÊ³ so that the basis coincides with the canonical one when the angles are null.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸, Ï•, â„¬Ë¢, ğá¶¿, ğáµ , ğÊ³ = init_spherical(symbols(&quot;Î¸ Ï•&quot;, real = true)...) ;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L371-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.invKM-Tuple{Type{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:(Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}), AbstractVecOrMat{T} where T}" href="#TensND.invKM-Tuple{Type{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:(Union{Tensors.Vec{dim, T}, Tensors.SymmetricTensor{2, dim, T, M} where M, Tensors.SymmetricTensor{4, dim, T, M} where M, Tensors.Tensor{2, dim, T, M} where M, Tensors.Tensor{4, dim, T, M} where M} where {dim, T}), AbstractVecOrMat{T} where T}"><code>TensND.invKM</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invKM(v::AbstractVecOrMat; kwargs...)</code></pre><p>Defines a tensor from a Kelvin-Mandel vector or matrix representation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L454-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.isorthogonal-Tuple{AbstractBasis}" href="#TensND.isorthogonal-Tuple{AbstractBasis}"><code>TensND.isorthogonal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isorthogonal(b::AbstractBasis)</code></pre><p>Checks whether the basis <code>b</code> is orthogonal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.isorthonormal-Tuple{AbstractBasis}" href="#TensND.isorthonormal-Tuple{AbstractBasis}"><code>TensND.isorthonormal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isorthonormal(b::AbstractBasis)</code></pre><p>Checks whether the basis <code>b</code> is orthonormal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.metric-Tuple{AbstractBasis, Val{:cov}}" href="#TensND.metric-Tuple{AbstractBasis, Val{:cov}}"><code>TensND.metric</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metric(b::AbstractBasis, var = :cov)</code></pre><p>Returns the covariant (if <code>var = :cov</code>) or contravariant (if <code>var = :cont</code>) metric matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}" href="#TensND.otimesul-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>TensND.otimesul</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">otimesul(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})</code></pre><p>Defines a special tensor product between two tensors of at least second order</p><p><code>(ğš âŠ Ë¢ ğ›) âŠ¡ ğ© = (ğš âŠ  ğ›) âŠ¡ (ğ© + áµ—ğ©)/2  = 1/2(aâ±áµbÊ²Ë¡+aâ±Ë¡bÊ²áµ) pâ‚–â‚— eáµ¢âŠ—eâ±¼</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L861-L867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.qcontract-Union{Tuple{order2}, Tuple{order1}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, order1}, AbstractArray{T2, order2}}} where {T1, T2, order1, order2}" href="#TensND.qcontract-Union{Tuple{order2}, Tuple{order1}, Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, order1}, AbstractArray{T2, order2}}} where {T1, T2, order1, order2}"><code>TensND.qcontract</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcontract(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})</code></pre><p>Defines a quadruple contracted product between two tensors</p><p><code>ğ”¸ âŠ™ ğ”¹ = Aáµ¢â±¼â‚–â‚—Bâ±Ê²áµË¡</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğ•€ = tğ•€(Sym) ; ğ• = tğ•(Sym) ; ğ•‚ = tğ•‚(Sym) ;

julia&gt; ğ•€ âŠ™ ğ•€
6

julia&gt; ğ• âŠ™ ğ•€
1

julia&gt; ğ•‚ âŠ™ ğ•€
5

julia&gt; ğ•‚ âŠ™ ğ•
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L695-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}" href="#TensND.sotimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>TensND.sotimes</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sotimes(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})</code></pre><p>Defines a symmetric tensor product between two tensors</p><p><code>(aâ±eáµ¢) âŠ—Ë¢ (bÊ²eâ±¼) = 1/2(aâ±bÊ² + aÊ²bâ±) eáµ¢âŠ—eâ±¼</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L922-L928">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.tensId2" href="#TensND.tensId2"><code>TensND.tensId2</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tensId2(T::Type{&lt;:Number} = Sym, dim = 3)
tğŸ(T::Type{&lt;:Number} = Sym, dim = 3)</code></pre><p>Identity tensor of second order <code>ğŸáµ¢â±¼ = Î´áµ¢â±¼ = 1 if i=j otherwise 0</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğŸ = tğŸ() ; KM(ğŸ)
6-element Vector{Sym}:
 1
 1
 1
 0
 0
 0

julia&gt; ğŸ.data
3Ã—3 SymmetricTensor{2, 3, Sym, 6}:
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L29-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.tensId4" href="#TensND.tensId4"><code>TensND.tensId4</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tensId4(T::Type{&lt;:Number} = Sym, dim = 3)
tğŸ™(T::Type{&lt;:Number} = Sym, dim = 3)</code></pre><p>Identity tensor of fourth order  <code>ğŸ™ = ğŸ âŠ  ğŸ</code> i.e. <code>(ğŸ™)áµ¢â±¼â‚–â‚— = Î´áµ¢â‚–Î´â±¼â‚—</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğŸ™ = tğŸ™() ; KM(ğŸ™)
9Ã—9 Matrix{Sym}:
 1  0  0  0  0  0  0  0  0
 0  1  0  0  0  0  0  0  0
 0  0  1  0  0  0  0  0  0
 0  0  0  1  0  0  0  0  0
 0  0  0  0  1  0  0  0  0
 0  0  0  0  0  1  0  0  0
 0  0  0  0  0  0  1  0  0
 0  0  0  0  0  0  0  1  0
 0  0  0  0  0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L56-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.tensId4s" href="#TensND.tensId4s"><code>TensND.tensId4s</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tensId4s(T::Type{&lt;:Number} = Sym, dim = 3)
tğ•€(T::Type{&lt;:Number} = Sym, dim = 3)</code></pre><p>Symmetric identity tensor of fourth order  <code>ğ•€ = ğŸ âŠ Ë¢ ğŸ</code> i.e. <code>(ğ•€)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğ•€ = tğ•€() ; KM(ğ•€)
6Ã—6 Matrix{Sym}:
 1  0  0  0  0  0
 0  1  0  0  0  0
 0  0  1  0  0  0
 0  0  0  1  0  0
 0  0  0  0  1  0
 0  0  0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L80-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.tensJ4" href="#TensND.tensJ4"><code>TensND.tensJ4</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tensJ4(T::Type{&lt;:Number} = Sym, dim = 3)
tğ•(T::Type{&lt;:Number} = Sym, dim = 3)</code></pre><p>Spherical projector of fourth order  <code>ğ• = (ğŸ âŠ— ğŸ) / dim</code> i.e. <code>(ğ•)áµ¢â±¼â‚–â‚— = Î´áµ¢â±¼Î´â‚–â‚—/dim</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğ• = tğ•() ; KM(ğ•)
6Ã—6 Matrix{Sym}:
 1/3  1/3  1/3  0  0  0
 1/3  1/3  1/3  0  0  0
 1/3  1/3  1/3  0  0  0
   0    0    0  0  0  0
   0    0    0  0  0  0
   0    0    0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L101-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.tensK4" href="#TensND.tensK4"><code>TensND.tensK4</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tensK4(T::Type{&lt;:Number} = Sym, dim = 3)
tğ•‚(T::Type{&lt;:Number} = Sym, dim = 3)</code></pre><p>Deviatoric projector of fourth order  <code>ğ•‚ = ğ•€ - ğ•</code> i.e. <code>(ğ•‚)áµ¢â±¼â‚–â‚— = (Î´áµ¢â‚–Î´â±¼â‚—+Î´áµ¢â‚—Î´â±¼â‚–)/2 - Î´áµ¢â±¼Î´â‚–â‚—/dim</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğ•‚ = tğ•‚() ; KM(ğ•‚)
6Ã—6 Matrix{Sym}:
  2/3  -1/3  -1/3  0  0  0
 -1/3   2/3  -1/3  0  0  0
 -1/3  -1/3   2/3  0  0  0
    0     0     0  1  0  0
    0     0     0  0  1  0
    0     0     0  0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L124-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.vecbasis-Tuple{AbstractBasis, Val{:cov}}" href="#TensND.vecbasis-Tuple{AbstractBasis, Val{:cov}}"><code>TensND.vecbasis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vecbasis(b::AbstractBasis, var = :cov)</code></pre><p>Returns the primal (if <code>var = :cov</code>) or primal (if <code>var = :cont</code>) basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/bases.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.ğ" href="#TensND.ğ"><code>TensND.ğ</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ğ(i::Int, dim::Int = 3, T::Type{&lt;:Number} = Sym)</code></pre><p>Vector of the canonical basis</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğ(1)
Tensnd{1, 3, Sym, Sym, Vec{3, Sym}, CanonicalBasis{3, Sym}}
# data: 3-element Vec{3, Sym}:
 1
 0
 0
# var: (:cont,)
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L145-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.ğË¢-Union{Tuple{Val{1}}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Val{1}, T1}, Tuple{Val{1}, T1, T2}, Tuple{Val{1}, T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}" href="#TensND.ğË¢-Union{Tuple{Val{1}}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Val{1}, T1}, Tuple{Val{1}, T1, T2}, Tuple{Val{1}, T1, T2, T3}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number}"><code>TensND.ğË¢</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğË¢(i::Int, Î¸::T = zero(Sym), Ï•::T = zero(Sym), Ïˆ::T = zero(Sym); canonical = false)</code></pre><p>Vector of the basis rotated with the 3 Euler angles <code>Î¸, Ï•, Ïˆ</code> (spherical if <code>Ïˆ=0</code>)</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸, Ï•, Ïˆ = symbols(&quot;Î¸, Ï•, Ïˆ&quot;, real = true) ;

Tensnd{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}
# data: 3-element Vec{3, Sym}:
 1
 0
 0
# var: (:cont,)
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 -sin(Ïˆ)â‹…sin(Ï•) + cos(Î¸)â‹…cos(Ïˆ)â‹…cos(Ï•)  -sin(Ïˆ)â‹…cos(Î¸)â‹…cos(Ï•) - sin(Ï•)â‹…cos(Ïˆ)  sin(Î¸)â‹…cos(Ï•)
  sin(Ïˆ)â‹…cos(Ï•) + sin(Ï•)â‹…cos(Î¸)â‹…cos(Ïˆ)  -sin(Ïˆ)â‹…sin(Ï•)â‹…cos(Î¸) + cos(Ïˆ)â‹…cos(Ï•)  sin(Î¸)â‹…sin(Ï•)
                        -sin(Î¸)â‹…cos(Ïˆ)                          sin(Î¸)â‹…sin(Ïˆ)         cos(Î¸)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L227-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.ğáµ–-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T&lt;:Number" href="#TensND.ğáµ–-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T&lt;:Number"><code>TensND.ğáµ–</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğáµ–(i::Int, Î¸::T = zero(Sym); canonical = false)</code></pre><p>Vector of the polar basis</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸ = symbols(&quot;Î¸&quot;, real = true) ;

julia&gt; ğáµ–(1, Î¸)
Tensnd{1, 2, Sym, Sym, Vec{2, Sym}, RotatedBasis{2, Sym}}
# data: 2-element Vec{2, Sym}:
 1
 0
# var: (:cont,)
# basis: 2Ã—2 Tensor{2, 2, Sym, 4}:
 cos(Î¸)  -sin(Î¸)
 sin(Î¸)   cos(Î¸)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L168-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensND.ğá¶œ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T&lt;:Number" href="#TensND.ğá¶œ-Union{Tuple{Val{1}}, Tuple{T}, Tuple{Val{1}, T}} where T&lt;:Number"><code>TensND.ğá¶œ</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğá¶œ(i::Int, Î¸::T = zero(Sym); canonical = false)</code></pre><p>Vector of the cylindrical basis</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Î¸ = symbols(&quot;Î¸&quot;, real = true) ;

julia&gt; ğá¶œ(1, Î¸)
Tensnd{1, 3, Sym, Sym, Vec{3, Sym}, RotatedBasis{3, Sym}}
# data: 3-element Vec{3, Sym}:
 1
 0
 0
# var: (:cont,)
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 cos(Î¸)  -sin(Î¸)  0
 sin(Î¸)   cos(Î¸)  0
      0        0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/special_tens.jl#L195-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}" href="#Tensors.dcontract-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>Tensors.dcontract</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcontract(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})</code></pre><p>Defines a double contracted product between two tensors</p><p><code>ğ›” âŠ¡ ğ›† = Ïƒâ±Ê²Îµáµ¢â±¼</code> <code>ğ›” = â„‚ âŠ¡ ğ›†</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ğ›† = Tensnd(SymmetricTensor{2,3}((i, j) -&gt; symbols(&quot;Îµ$i$j&quot;, real = true))) ;

julia&gt; k, Î¼ = symbols(&quot;k Î¼&quot;, real =true) ;

julia&gt; â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;

julia&gt; ğ›” = â„‚ âŠ¡ ğ›†
Tensnd{2, 3, Sym, Sym, SymmetricTensor{2, 3, Sym, 6}, CanonicalBasis{3, Sym}}
# data: 3Ã—3 SymmetricTensor{2, 3, Sym, 6}:
 Îµ11*(k + 4*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ21â‹…Î¼                                              2â‹…Îµ31â‹…Î¼
                                             2â‹…Îµ21â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k + 4*Î¼/3) + Îµ33*(k - 2*Î¼/3)                                              2â‹…Îµ32â‹…Î¼
                                             2â‹…Îµ31â‹…Î¼                                              2â‹…Îµ32â‹…Î¼  Îµ11*(k - 2*Î¼/3) + Îµ22*(k - 2*Î¼/3) + Îµ33*(k + 4*Î¼/3)
# var: (:cont, :cont)
# basis: 3Ã—3 Tensor{2, 3, Sym, 9}:
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L566-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{orderS, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, orderS, order2, dim}" href="#Tensors.dotdot-Union{Tuple{dim}, Tuple{order2}, Tuple{orderS}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{orderS, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, orderS, order2, dim}"><code>Tensors.dotdot</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dotdot(v1::AbstractTensnd{order1,dim}, S::AbstractTensnd{orderS,dim}, v2::AbstractTensnd{order2,dim})</code></pre><p>Defines a bilinear operator <code>ğ¯â‚â‹…ğ•Šâ‹…ğ¯â‚‚</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; n = Tensnd(Sym[0, 0, 1]) ;

julia&gt; k, Î¼ = symbols(&quot;k Î¼&quot;, real =true) ;

julia&gt; â„‚ = 3k * tğ•() + 2Î¼ * tğ•‚() ;

julia&gt; dotdot(n,â„‚,n) # Acoustic tensor
3Ã—3 Tensnd{2, 3, Sym, Sym, Tensor{2, 3, Sym, 9}, CanonicalBasis{3, Sym}}:
 Î¼  0          0
 0  Î¼          0
 0  0  k + 4*Î¼/3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L648-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}" href="#Tensors.otimes-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>Tensors.otimes</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">otimes(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})</code></pre><p>Defines a tensor product between two tensors</p><p><code>(aâ±eáµ¢) âŠ— (bÊ²eâ±¼) = aâ±bÊ² eáµ¢âŠ—eâ±¼</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L473-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}" href="#Tensors.otimesu-Union{Tuple{dim}, Tuple{order2}, Tuple{order1}, Tuple{TensND.AbstractTensnd{order1, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}, TensND.AbstractTensnd{order2, dim, T, A} where {T&lt;:Number, A&lt;:AbstractArray}}} where {order1, order2, dim}"><code>Tensors.otimesu</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">otimesu(t1::AbstractTensnd{order1,dim}, t2::AbstractTensnd{order2,dim})</code></pre><p>Defines a special tensor product between two tensors of at least second order</p><p><code>(ğš âŠ  ğ›) âŠ¡ ğ© = ğšâ‹…ğ©â‹…ğ› = aâ±áµbÊ²Ë¡pâ‚–â‚— eáµ¢âŠ—eâ±¼</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jfbarthelemy/TensND.jl/blob/ecbdc4ddef19ee06179d3590a24a0a90539ccf80/src/tensnd_struct.jl#L789-L795">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 10 September 2021 00:25">Friday 10 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
